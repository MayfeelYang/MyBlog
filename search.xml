<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[sulley的架构]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2017/02/14/sulley%E7%9A%84%E6%9E%B6%E6%9E%84/</url>
      <content type="html"><![CDATA[<h1 id="sulley架构图"><a href="#sulley架构图" class="headerlink" title="sulley架构图"></a>sulley架构图</h1><p><img src="file:///Users/Mayfeel/MyBlog/source/_posts/media/14870374558193.jpg" alt="整体结构图"></p>
<h2 id="四个主要组成部分"><a href="#四个主要组成部分" class="headerlink" title="四个主要组成部分"></a>四个主要组成部分</h2><ul>
<li><strong>Data Generation</strong><ul>
<li>You build requests out of primitives and legos</li>
<li>Legos are complex types that extend the framework</li>
</ul>
</li>
<li><strong>Session Management / Driver</strong><ul>
<li>Requests are chained together in a graph to form a session</li>
<li>The session class exposes a standalone web interface for monitoring and control</li>
<li>The driver ties targets, agents and requests together</li>
</ul>
</li>
<li><strong>Agents</strong><ul>
<li>Interface with the target for instrumentation and logging purposes</li>
</ul>
</li>
<li><strong>Utilities</strong><ul>
<li>Standalone command line utilities that perform a variety of task</li>
</ul>
</li>
</ul>
<h2 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h2><ol>
<li>Sniff some traffic or reverse some protocol parsing binary</li>
<li>Break the target protocol into individual requests</li>
<li>Represent each request with a series of primitives<ul>
<li>Individual requests can be tasked out to different people</li>
</ul>
</li>
<li>Setup some targets in conjunction with various agents</li>
<li>Write a driver script which instantiates a session and ties requests, agents and the targets together</li>
<li>Fuzz!</li>
<li>Review results</li>
</ol>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>这个例展示了多种路径和深度。<br><img src="media/14870382907344.jpg" alt="session示意图"></p>
<h2 id="Agents"><a href="#Agents" class="headerlink" title="Agents"></a>Agents</h2><ul>
<li>A flexible sub-system allows you to create custom agents</li>
<li>Client-server communication is extremely simple over ”PedRPC”<ul>
<li>Create a class that extend from pedrpc.server</li>
<li>Instantiate pedrpc.client</li>
<li>Call class members as if they are local</li>
</ul>
</li>
<li>Some agents have already been developed…</li>
</ul>
<h2 id="Driver"><a href="#Driver" class="headerlink" title="Driver"></a>Driver</h2><ul>
<li>The driver is where it all comes together:<ul>
<li>Import requests from the request library</li>
<li>Instantiate a session instance</li>
<li>Instantiate and add target instances to the session</li>
<li>Interconnect the requests to form a graph</li>
<li>Start fuzzing</li>
</ul>
</li>
<li>This is where edge and pre/post send callbacks should be defined</li>
<li>The driver is entirely free form, though must of them will follow a simple and similar structure</li>
</ul>
<p><strong>Driver的例子</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> sulley <span class="keyword">import</span> *</div><div class="line"><span class="keyword">from</span> requests <span class="keyword">import</span> jabber</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_message</span> <span class="params">(sock)</span>:</span></div><div class="line">	init = <span class="string">'&lt;?xml version="1.0" encoding="UTF-8" ?&gt;\n'</span></div><div class="line">	init += <span class="string">'&lt;stream:stream to="10.10.20.16" xmlns="jabber:client" xmlns:stream="http://etherx.jabber.org"&gt;'</span></div><div class="line">	sock.send(init)</div><div class="line">	sock.recv(<span class="number">1024</span>)</div><div class="line"></div><div class="line">sess = sessions.session(session filename=<span class="string">"audits/trillian.session"</span>)</div><div class="line">target = sessions.target(<span class="string">"10.10.20.16"</span>, <span class="number">5298</span>)</div><div class="line">target.netmon = pedrpc.client(<span class="string">"10.10.20.16"</span>, <span class="number">26001</span>)</div><div class="line">target.procmon = pedrpc.client(<span class="string">"10.10.20.16"</span>, <span class="number">26002</span>)</div><div class="line">target.vmcontrol = pedrpc.client(<span class="string">"127.0.0.1"</span>, <span class="number">26003</span>)</div><div class="line"></div><div class="line"><span class="comment"># start up the target.</span></div><div class="line">target.vmcontrol.restart_target()</div><div class="line"><span class="keyword">print</span> <span class="string">"virtual machine up and running"</span></div><div class="line">sess.add_target(target)</div><div class="line">sess.pre_send = init_message</div><div class="line">sess.connect(s_get(<span class="string">"chat message"</span>))</div><div class="line">sess.fuzz()</div></pre></td></tr></table></figure>
<p>如上所示的<strong>driver的例子</strong>就可以展示一个大概的sulley的工作流程：</p>
<ol>
<li>初始化一个session</li>
<li>初始化一个target</li>
<li>为target设置监控（netmon / procmon / vmcontrol）</li>
<li>启动target</li>
<li>将target添加至session</li>
<li>用户可自定义pre_send函数和post_send函数</li>
<li>session.connect</li>
<li>进行模糊测试（session.fuzz）</li>
</ol>
<h1 id="sulley的模糊测试流程"><a href="#sulley的模糊测试流程" class="headerlink" title="sulley的模糊测试流程"></a>sulley的模糊测试流程</h1><p>session类中<strong>fuzz()</strong>函数的实现。<br><u>@ param1: this_node (default = None)<br>    @ param2: path (default = [])<br></u><br><img src="media/14870438262972.jpg" alt="模糊测试流程图"></p>
<h1 id="sulley的变异"><a href="#sulley的变异" class="headerlink" title="sulley的变异"></a>sulley的变异</h1><h1 id="sulley的监控"><a href="#sulley的监控" class="headerlink" title="sulley的监控"></a>sulley的监控</h1><p><img src="media/14870439095318.png" alt="监控pedrpc"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[几种常见模式识别算法的整理和总结]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2017/01/11/%E5%87%A0%E7%A7%8D%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E7%AE%97%E6%B3%95%E7%9A%84%E6%95%B4%E7%90%86%E5%92%8C%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="1-K-Nearest-Neighbor"><a href="#1-K-Nearest-Neighbor" class="headerlink" title="1.K-Nearest Neighbor"></a>1.K-Nearest Neighbor</h1><p>K-NN可以说是一种最直接的用来分类未知数据的方法。基本通过下面这张图跟文字说明就可以明白K-NN是干什么的<br><img src="file:///Users/Mayfeel/MyBlog/source/_posts/pic/h.png" alt="k-nn"><br>简单来说，K-NN可以看成：有那么一堆你已经知道分类的数据，然后当一个新数据进入的时候，就开始跟训练数据里的每个点求距离，然后挑离这个训练数据最近的K个点看看这几个点属于什么类型，然后用少数服从多数的原则，给新数据归类。一个比较好的介绍k-NN的课件可以见下面链接，图文并茂，我当时一看就懂了<br><a href="http://courses.cs.tamu.edu/rgutier/cs790_w02/l8.pdf" target="_blank" rel="external">http://courses.cs.tamu.edu/rgutier/cs790_w02/l8.pdf</a></p>
<p>实际上K-NN本身的运算量是相当大的，因为数据的维数往往不止2维，而且训练数据库越大，所求的样本间距离就越多。就拿我们course project的人脸检测来说，输入向量的维数是1024维(32x32的图，当然我觉得这种方法比较silly)，训练数据有上千个，所以每次求距离(这里用的是欧式距离，就是我们最常用的平方和开根号求距法) 这样每个点的归类都要花上上百万次的计算。所以现在比较常用的一种方法就是kd-tree。也就是把整个输入空间划分成很多很多小子区域，然后根据临近的原则把它们组织为树形结构。然后搜索最近K个点的时候就不用全盘比较而只要比较临近几个子区域的训练数据就行了。kd-tree的一个比较好的课件可以见下面链接：<br><a href="https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf" target="_blank" rel="external">https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf</a></p>
<p>当然，kd-tree有一个问题就是当输入维数跟训练数据数量很接近时就很难优化了。所以用PCA(稍后会介绍)降维大多数情况下是很有必要的</p>
<h1 id="2-Bayes-Classifier"><a href="#2-Bayes-Classifier" class="headerlink" title="2.Bayes Classifier"></a>2.Bayes Classifier</h1><p>贝叶斯方法一篇比较科普的中文介绍可以见pongba的平凡而神奇的贝叶斯方法: <mark><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method" target="_blank" rel="external">http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/</a></mark>，实际实现一个贝叶斯分类器之后再回头看这篇文章，感觉就很不一样。  </p>
<p>在模式识别的实际应用中，贝叶斯方法绝非就是post正比于prior*likelihood这个公式这么简单，一般而言我们都会用正态分布拟合likelihood来实现。  </p>
<p>用正态分布拟合是什么意思呢？贝叶斯方法式子的右边有两个量，一个是prior先验概率，这个求起来很简单，就是一大堆数据中求某一类数据占的百分比就可以了，比如300个一堆的数据中A类数据占100个，那么A的先验概率就是1/3。第二个就是likelihood，likelihood可以这么理解：对于每一类的训练数据，我们都用一个multivariate正态分布来拟合它们(即通过求得某一分类训练数据的平均值和协方差矩阵来拟合出一个正态分布)，然后当进入一个新的测试数据之后，就分别求取这个数据点在每个类别的正态分布中的大小，然后用这个值乘以原先的prior便是所要求得的后验概率post了。  </p>
<p>贝叶斯公式中还有一个evidence，对于初学者来说，可能会一下没法理解为什么在实际运算中它不见了。实则上，evidence只是一个让最后post归一化的东西，而在模式分类中，我们只需要比较不同类别间post的大小，归一化反而增加了它的运算量。当然，在有的地方，这个evidence绝对不能省，比如后文提到的GMM中，需要用到EM迭代，这时候如果不用evidence将post归一化，后果就会很可怕。<br>Bayes方法一个不错的参考网页可见下面链接：<br><a href="http://www.cs.mcgill.ca/~mcleish/644/main.html" target="_blank" rel="external">http://www.cs.mcgill.ca/~mcleish/644/main.html</a></p>
<h1 id="3-Principle-Component-Analysis"><a href="#3-Principle-Component-Analysis" class="headerlink" title="3.Principle Component Analysis"></a>3.Principle Component Analysis</h1><p>PCA，译为主元分析或者主成份分析，是一种很好的简化数据的方法，也是PR中常见到不能再常见的算法之一。CSDN上有一篇很不错的中文博客介绍PCA，《主元分析(PCA)理论分析及应用》，可以见下面链接：<br><a href="http://blog.csdn.net/ayw_hehe/archive/2010/07/16/5736659.aspx" target="_blank" rel="external">http://blog.csdn.net/ayw_hehe/archive/2010/07/16/5736659.aspx</a><br>对于我而言，主元分析最大的意义就是让我明白了线性代数中特征值跟特征向量究竟代表什么，从而让我进一步感受到了线性代数的博大精深魅力无穷。- -|||</p>
<p>PCA简而言之就是根据输入数据的分布给输入数据重新找到更能描述这组数据的正交的坐标轴，比如对于那个椭圆状的分布，最方便表示这个分布的坐标轴肯定是椭圆的长轴短轴而不是原来的x y。</p>
<p>那么如何求出这个长轴和短轴呢？于是线性代数就来了：我们求出这堆数据的协方差矩阵(关于什么是协方差矩阵，详见本节最后附的链接)，然后再求出这个协方差矩阵的特征值和特征向量，对应最大特征值的那个特征向量的方向就是长轴(也就是主元)的方向，次大特征值的就是第二主元的方向，以此类推。</p>
<p>关于PCA，推荐两个不错的tutorial:<br>(1) A tutorial on Principle Component Analysis从最基本的数学原理到应用都有，让我在被老师的讲课弄晕之后瞬间开悟的tutorial:<a href="http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf" target="_blank" rel="external">http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf</a><br>(2) 里面有一个很生动的实现PCA的例子，还有告诉你PCA跟SVD是什么关系的，对编程实现的帮助很大(当然大多数情况下都不用自己编了):<a href="http://www.math.ucsd.edu/~gptesler/283/pca_07-handout.pdf" target="_blank" rel="external">http://www.math.ucsd.edu/~gptesler/283/pca_07-handout.pdf</a>(不能使用)</p>
<h1 id="4-Linear-Discriminant-Analysis"><a href="#4-Linear-Discriminant-Analysis" class="headerlink" title="4.Linear Discriminant Analysis"></a>4.Linear Discriminant Analysis</h1><p>LDA，基本和PCA是一对双生子，它们之间的区别就是PCA是一种unsupervised的映射方法而LDA是一种supervised映射方法，这一点可以从下图中一个2D的例子简单看出</p>
<p><img src="file:///Users/Mayfeel/MyBlog/source/_posts/pic/114542_1292688413RtUs.png" alt="lda"></p>
<p>图的左边是PCA，它所作的只是将整组数据整体映射到最方便表示这组数据的坐标轴上，映射时没有利用任何数据内部的分类信息。因此，虽然做了PCA后，整组数据在表示上更加方便(降低了维数并将信息损失降到最低)，但在分类上也许会变得更加困难；图的右边是LDA，可以明显看出，在增加了分类信息之后，两组输入映射到了另外一个坐标轴上，有了这样一个映射，两组数据之间的就变得更易区分了(在低维上就可以区分，减少了很大的运算量)。</p>
<p>在实际应用中，最常用的一种LDA方法叫作Fisher Linear Discriminant，其简要原理就是求取一个线性变换，是的样本数据中“between classes scatter matrix”(不同类数据间的协方差矩阵)和“within classes scatter matrix”(同一类数据内部的各个数据间协方差矩阵)之比的达到最大。关于Fisher LDA更具体的内容可以见下面课件，写的很不错~</p>
<p><a href="http://www.csd.uwo.ca/~olga/Courses//CS434a_541a//Lecture8.pdf" target="_blank" rel="external">http://www.csd.uwo.ca/~olga/Courses//CS434a_541a//Lecture8.pdf</a> </p>
<p><br \=""><br><br \=""><br><br \=""><br><br \=""></p>
<p>转自<a href="http://blog.csdn.net/scyscyao/article/details/5987581" target="_blank" rel="external">http://blog.csdn.net/scyscyao/article/details/5987581</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[IDA学习笔记(1)]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/23/IDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<h1 id="第一章-反汇编简介"><a href="#第一章-反汇编简介" class="headerlink" title="第一章 反汇编简介"></a>第一章 反汇编简介</h1><h2 id="何为反汇编"><a href="#何为反汇编" class="headerlink" title="何为反汇编"></a>何为反汇编</h2><p>使用一些工具来撤销汇编的过程。<br>为何反汇编困难重重：</p>
<ul>
<li>编译过程会造成损失。机器语言中没有变量或是函数名，变量类型信息只有通过数据的用途来确定。</li>
<li>编译属于多对多的操作。源程序可以通过许多不同的方式被转换为汇编语言。因此，编译一个文件，并立即反编译，可能会得到与输入是截然不同的源文件。</li>
<li>反编译器非常依赖于语言和库。</li>
<li>要向准确的反编译一个二进制文件，需要近乎完美的反汇编能力。</li>
</ul>
<h2 id="为何反汇编"><a href="#为何反汇编" class="headerlink" title="为何反汇编"></a>为何反汇编</h2><ul>
<li>分析恶意软件。静态分析。</li>
<li>分析闭源软件的漏洞</li>
<li>分析闭源软件的互操作性</li>
<li>分析编译器生成的代码，以验证编译器的性能和准确性</li>
<li>在调试是显示程序指令</li>
</ul>
<h2 id="如何反汇编"><a href="#如何反汇编" class="headerlink" title="如何反汇编"></a>如何反汇编</h2><h3 id="基本的反汇编算法"><a href="#基本的反汇编算法" class="headerlink" title="基本的反汇编算法"></a>基本的反汇编算法</h3><ul>
<li><strong>确定进行反汇编的代码区域</strong>。要考虑到指令和数据是混杂在一起的，反汇编可执行文件，一般都符合可执行文件的某种通用格式，在格式中通常确定了文件中包含代码和代码入口点等。</li>
<li><strong>知道指令的起始地址后，下一步就是读取该地址（或文件偏移量）所包含的值，并执行一次表查找，将二进制操作码的值与它的汇编语言助记符对应起来。</strong>根据被反汇编的指令集的不同，这个操作的复杂程度也不同。</li>
<li><strong>获取指令并解码任何所需操作数后，需要对他的汇编语言等价形式进行格式化，并将其在反汇编代码中输出。</strong>如：x86汇编语言所使用的两种格式为Intel格式和AT&amp;T格式。</li>
<li>输出一条指令之后，继续反汇编下一条指令。</li>
</ul>
<h3 id="线性扫描反汇编"><a href="#线性扫描反汇编" class="headerlink" title="线性扫描反汇编"></a>线性扫描反汇编</h3><p>该算法采用了一种非常简单的方法来确定需要反汇编的指令的位置：一条指令结束的地方、另一条指令开始的地方。<strong>确定起始位置最为困难</strong>。<br>常用的解决办法是，假设程序中标注为代码（通常有程序文件的头部指定）的节所包含的全部是机器语言指令。<br>这种算法并不会通过识别分支等非线性指令来了解程序的控制流。<br><strong>优点</strong>：能够完全覆盖程序的所有代码。<br><strong>缺点</strong>：没有考虑到代码中可能混有数据。<br>GNU调试器（gdb）、微软WinDbg和objdump的反汇编引擎均采用线性扫描算法。</p>
<h3 id="递归下降反汇编"><a href="#递归下降反汇编" class="headerlink" title="递归下降反汇编"></a>递归下降反汇编</h3><p>这种算法强调控制流的概念。控制流根据一条指令是否被另一条指令引用来决定是否对其反汇编。依据不同类型的指令对CPU指令指针的影响的不同进行分类（1）顺序流指令（2）条件分支指令（3）无条件分支指令（4）函数调用指令（5）返回指令<br><strong>优点</strong>：具有区分嗲吗与数据的强大能力。<br><strong>缺点</strong>：无法处理间接代码路径，如利用指针表来查找目标地址的跳转或调用。<br>IDA pro是典型的递归下降反汇编工具。</p>
<p>《未完待续。。。。》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OSS-FUZZ相关调研]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/14/OSS-FUZZ%E7%9B%B8%E5%85%B3%E8%B0%83%E7%A0%94/</url>
      <content type="html"><![CDATA[<h1 id="第一次调研"><a href="#第一次调研" class="headerlink" title="第一次调研"></a>第一次调研</h1><h2 id="OSS-Fuzz概况"><a href="#OSS-Fuzz概况" class="headerlink" title="OSS-Fuzz概况"></a>OSS-Fuzz概况</h2><p>OSS-Fuzz与<a href="https://www.coreinfrastructure.org/" target="_blank" rel="external">Core Infrastructure Initiative</a>合作，目标是希望利用模糊测试技术以及分布式执行技术使开源软件更加安全可靠。<br>在OSS-Fuzz的第一阶段，开发者使用了带有Sanitizer的LibFuzzer，目前OSS-Fuzz仅支持C和C++语言。  </p>
<h3 id="Process-Overview"><a href="#Process-Overview" class="headerlink" title="Process Overview"></a>Process Overview</h3><p>OSS-Fuzz的整个流程如下：</p>
<ul>
<li>开源项目的维护这创建一个或多个fuzz target（也就是LibFuzzer中必须重载的LLVMFuzzerTestOneInput函数），并使用OSS-Fuzz项目中的创建及测试系统对它们进行<a href="https://github.com/google/oss-fuzz/blob/master/docs/ideal_integration.md" target="_blank" rel="external">整合</a>，构建出一个待测项目。</li>
<li>OSS-Fuzz接收待测项目。</li>
<li>当ClusterFuzz发现bug后，一个issue将在OSS-Fuzz的<a href="https://bugs.chromium.org/p/oss-fuzz/issues/list" target="_blank" rel="external">issue tracker</a>上面进行公布。Project owners are <strong>CC-ed</strong> to the bug report.</li>
<li>维护者修复bug。</li>
<li>ClusterFuzz自动确认已修复的bug，添加评注并关闭issue。</li>
<li>修复的7天后将被verified，90天后将会公布出来。  </li>
</ul>
<h2 id="Announcing-OSS-Fuzz-Continuous-fuzzing-for-open-source-software"><a href="#Announcing-OSS-Fuzz-Continuous-fuzzing-for-open-source-software" class="headerlink" title="Announcing OSS-Fuzz: Continuous fuzzing for open source software"></a>Announcing OSS-Fuzz: Continuous fuzzing for open source software</h2><p><a href="https://opensource.googleblog.com/2016/12/announcing-oss-fuzz-continuous-fuzzing.html" target="_blank" rel="external">参考链接</a> </p>
<blockquote>
<p>In recent years, several efficient general purpose fuzzing engines have been implemented (e.g. AFL and libFuzzer), and we use them to fuzz various components of the Chrome browser. These fuzzers, when combined with <strong>Sanitizers</strong>, can help find <strong>security vulnerabilities</strong> (e.g. buffer overflows, use-after-free, bad casts, integer overflows, etc), <strong>stability bugs</strong> (e.g. null dereferences, memory leaks, out-of-memory, assertion failures, etc) and sometimes even <strong>logical bugs</strong>.  </p>
</blockquote>
<p>文中说<a href="https://github.com/google/oss-fuzz" target="_blank" rel="external">OSS-Fuzz</a>将包含多种多样的模糊测试引擎（一开始是LibFuzzer），以及各种Sanitizers（一开始是AddressSanitizer），并且提供了一个由<a href="https://github.com/google/oss-fuzz/blob/master/docs/clusterfuzz.md" target="_blank" rel="external">ClusterFuzz</a>组成的大规模分布式执行环境。  </p>
<p><mark><strong><em>这里简介一下ClusterFuzz：</em></strong></mark><br>ClusterFuzz是位于OSS-Fuzz的后端，一开始是为了规模化的测试Chrome用的。ClusterFuzz将提供（貌似开发工作正在进行中）:  </p>
<ul>
<li><p><strong>一个web interface来查看目标程序的测试情况（如：速度、覆盖信息、内存使用情况、crash信息）。</strong><br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/freetype_stats.png" alt="fuzzer states">  </p>
</li>
<li><p><strong>提供的coverage报告会中还会高亮标记源代码中覆盖到的语句。</strong><br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/freetype_coverage_1.png" alt="coverage report 1">  </p>
</li>
<li><p><strong>高亮标记</strong><br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/freetype_coverage_2.png" alt="coverage report 2">  </p>
</li>
<li><p><strong>crash报告中，含有stack trace、导致crash的样本、bug有可能发生的位置等。</strong><br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/pcre2_testcase.png" alt="crash report"></p>
</li>
</ul>
<h3 id="Early-successes"><a href="#Early-successes" class="headerlink" title="Early successes"></a>Early successes</h3><p>这一部分讲述了开发者使用OSS-FUZZ得到了很好的结果，开发者的其中一个测试目标为<a href="https://www.freetype.org/" target="_blank" rel="external">FreeType</a>，开发者构建了一个<a href="http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/tools/ftfuzzer/ftfuzzer.cc" target="_blank" rel="external">FreeTypeFuzzer</a>仅在源代码更新后的几个小时之内就发现了一个新的heap buffer overflow的漏洞。之后OSS-Fuzz通知相关的漏洞修补人员，最后OSS-Fuzz将自动的对修补后的结果进行确认。所有的过程在一天之内就完成了。  </p>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><p>OSS-Fuzz已经发现了150个<a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?can=1&amp;q=-component%3AInfra+-status%3ADuplicate%2CWontFix&amp;sort=-id&amp;colspec=ID+Type+Component+Status+Library+Reported+Owner+Summary&amp;cells=ids" target="_blank" rel="external">bug</a>（每周能产生4万亿个测试用例）。  </p>
<h1 id="第二次调研"><a href="#第二次调研" class="headerlink" title="第二次调研"></a>第二次调研</h1><h2 id="Ideal-integration-with-OSS-Fuzz"><a href="#Ideal-integration-with-OSS-Fuzz" class="headerlink" title="Ideal integration with OSS-Fuzz"></a>Ideal integration with OSS-Fuzz</h2><p>开源项目有不同的编译方法和测试环境，而且<strong>不能</strong>要求开发者为了配合oss-fuzz平台对开源软件进行统一实现。这一部分主要列举了几个特征，可以尽量使自动化模糊测试更简单、有效率。  </p>
<h3 id="Fuzz-Target"><a href="#Fuzz-Target" class="headerlink" title="Fuzz Target"></a>Fuzz Target</h3><p>fuzz target的代码应该是开源项目源代码中的一部分，开发人员提交fuzz target的时候应该在本地进行以下短时间的测试，确保没有fuzz target本身没有crash、hang、内存耗尽等问题。  </p>
<h3 id="Seed-Corpus"><a href="#Seed-Corpus" class="headerlink" title="Seed Corpus"></a>Seed Corpus</h3><p>种子的质量对模糊测试效率的影响很大。<strong>理想</strong>的种子集应该是拥有最大覆盖率的数目最少的一个集合。为了更好的配合oss-fuzz，种子集希望是那种可以迭代使用的。</p>
<h3 id="Regression-Testing"><a href="#Regression-Testing" class="headerlink" title="Regression Testing"></a>Regression Testing</h3><p>fuzz target可以进行regression testing（不是必须的）。将fuzz target和一个简单的driver相连，fuzz target先运行提供的输入，后使用driver运行之前一步中产生的种子集。例如SQLite、openssl  </p>
<h3 id="Fuzzing-dictionary"><a href="#Fuzzing-dictionary" class="headerlink" title="Fuzzing dictionary"></a>Fuzzing dictionary</h3><p>最好有一个包含输入文件中关键字的字典。如XML解析器。</p>
<h3 id="Build-support"><a href="#Build-support" class="headerlink" title="Build support"></a>Build support</h3><p>由于开源项目中有太多build体系存在。一个理想的能够很好的支持oss-fuzz是这样的：  </p>
<ul>
<li>项目中每个目标foo函数，都有对应的编译规则，一个项目包应该包含：模糊测试入口函数（LLVMFuzzerTestOneInput），以及所有依赖的代码。</li>
<li>build系统应该支持更改编译器和增加compiler flags。如下：<br><code>CC=&quot;clang $FUZZER_FLAGS&quot; CXX=&quot;clang++ $FUZZER_FLAGS&quot; make_or_whatever_other_command foo_fuzzer.a</code>  </li>
</ul>
<h2 id="Setting-up-New-Project"><a href="#Setting-up-New-Project" class="headerlink" title="Setting up New Project"></a>Setting up New Project</h2><h3 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h3><ul>
<li>Fuzz targets</li>
<li>Install docker</li>
</ul>
<h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p>想要在OSS-Fuzz中添加一个新的开源项目，你需要一个OSS-Fuzz repository的<code>projects/</code>目录下的子目录，如：boringssl项目位于<code>projects/boringssl</code>。</p>
<p>项目目录需要包括以下三个配置文件：  </p>
<ul>
<li><code>projects/&lt;project_name&gt;/Dockerfile</code> - 定义了项目所需的<strong>测试依赖环境</strong>和项目的<strong>fuzz targets</strong>。<a href="https://github.com/google/oss-fuzz/blob/master/projects/boringssl/Dockerfile" target="_blank" rel="external">例</a></li>
<li><code>projects/&lt;project_name&gt;/build.sh</code> - build script，用来编译测试依赖环境。<a href="https://github.com/google/oss-fuzz/blob/master/projects/boringssl/build.sh" target="_blank" rel="external">例</a></li>
<li><code>projects/&lt;project_name&gt;/project.yaml</code> - 提供与项目相关的metadata。<a href="https://github.com/google/oss-fuzz/blob/master/projects/boringssl/project.yaml" target="_blank" rel="external">例</a></li>
</ul>
<p>为项目自动创建一个新的目录以及生成配置文件模板代码如下:</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd /path/to/oss-fuzz  </div><div class="line">$ <span class="keyword">export</span> PROJECT_NAME=&lt;project_name&gt;  </div><div class="line">$ python infra/helper<span class="variable">.py</span> <span class="keyword">generate</span> $PROJECT_NAME</div></pre></td></tr></table></figure>
<p><a href="https://github.com/google/oss-fuzz/blob/master/infra/helper.py" target="_blank" rel="external">infra/helper.py</a></p>
<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>为了能够成在cluster fuzz上面部署。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">FROM</span> ossfuzz/base-builder                 <span class="comment"># base image with clang toolchain</span></div><div class="line"><span class="keyword">MAINTAINER</span> YOUR_EMAIL                     <span class="comment"># maintainer for this file</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install -y ...                <span class="comment"># install required packages to build your project</span></span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> git <span class="built_in">clone</span> &lt;git_url&gt; &lt;checkout_dir&gt;    <span class="comment"># checkout all sources needed to build your project</span></span></div><div class="line"><span class="keyword">WORKDIR</span><span class="bash"> &lt;checkout_dir&gt;                    <span class="comment"># current directory for build script</span></span></div><div class="line"><span class="keyword">COPY</span><span class="bash"> build.sh fuzzer.cc <span class="variable">$SRC</span>/             <span class="comment"># copy build script and other fuzzer files in src dir</span></span></div></pre></td></tr></table></figure>
<h3 id="build-sh"><a href="#build-sh" class="headerlink" title="build.sh"></a>build.sh</h3><p>注意：</p>
<ul>
<li>不要把LibFuzzer想成唯一的模糊测试引擎，在将来oss-fuzz中会增加其他模糊测试引擎，如AFL。所以要使用<mark><code>-lFuzzingEngine</code>选项来link模糊测试引擎。</mark></li>
<li>确保fuzz targets的名字仅由字母、”_”、”-“组成。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/bin/bash -eu</span></div><div class="line"></div><div class="line">./buildconf.sh</div><div class="line"><span class="comment"># configure scripts usually use correct environment variables.</span></div><div class="line">./configure</div><div class="line"></div><div class="line">make clean</div><div class="line">make -j$(nproc) all</div><div class="line"></div><div class="line"><span class="variable">$CXX</span> <span class="variable">$CXXFLAGS</span> -std=c++11 -Ilib/ \</div><div class="line">    <span class="variable">$SRC</span>/parse_fuzzer.cc -o <span class="variable">$OUT</span>/parse_fuzzer \</div><div class="line">    <span class="_">-l</span>FuzzingEngine .libs/libexpat.a</div><div class="line"></div><div class="line">cp <span class="variable">$SRC</span>/*.dict <span class="variable">$SRC</span>/*.options <span class="variable">$OUT</span>/</div></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:left">Location</th>
<th style="text-align:left">Env</th>
<th style="text-align:left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">/out/</td>
<td style="text-align:left">$OUT</td>
<td style="text-align:left">Directory to store build artifacts (fuzz targets, dictionaries, options files, seed corpus archives)</td>
</tr>
<tr>
<td style="text-align:left">/src/</td>
<td style="text-align:left">$SRC</td>
<td style="text-align:left">Directory to checkout source files</td>
</tr>
<tr>
<td style="text-align:left">/work/</td>
<td style="text-align:left">$WORK</td>
<td style="text-align:left">Directory for storing intermediate files</td>
</tr>
<tr>
<td style="text-align:left">/usr/lib/libFuzzingEngine.a</td>
<td style="text-align:left">$LIB_FUZZING_ENGINE</td>
<td style="text-align:left">Location of prebuilt fuzzing engine library (e.g. libFuzzer ) that needs to be linked with all fuzz targets (-lFuzzingEngine)</td>
</tr>
</tbody>
</table>
<h3 id="Testing-locally"><a href="#Testing-locally" class="headerlink" title="Testing locally"></a>Testing locally</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cd /path/to/oss-fuzz</div><div class="line">$ python infra/helper<span class="selector-class">.py</span> build_image <span class="variable">$PROJECT_NAME</span></div><div class="line">$ python infra/helper<span class="selector-class">.py</span> build_fuzzers <span class="variable">$PROJECT_NAME</span></div></pre></td></tr></table></figure>
<p>可以将编译好的二进制文件放入你的机器上面的<code>/path/to/oss-fuzz/build/out/$PROJECT_NAME</code>中，后执行以下命令确保正常运行：<br><code>$ python infra/helper.py run_fuzzer $PROJECT_NAME &lt;fuzz_target&gt;</code><br>如果运行以上命令后的结果是正常的，那么，它在oss-fuzz平台上就可以正常运行。<br>另外，可以查看代码覆盖率。<br><code>$ python infra/helper.py coverage $PROJECT_NAME &lt;fuzz_target&gt;</code></p>
<h3 id="Debugging-Problems"><a href="#Debugging-Problems" class="headerlink" title="Debugging Problems"></a>Debugging Problems</h3><p>可以在<code>myfuzzer</code>的目录里面创建<code>my_fuzzer.options</code>文件来设置LibFuzzer的一些参数。<a href="http://llvm.org/docs/LibFuzzer.html#options" target="_blank" rel="external">List of available options</a></p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="section">[libfuzzer]</span></div><div class="line"><span class="attr">dict</span> = xml.dict</div><div class="line"><span class="attr">max_len</span> = <span class="number">1024</span></div></pre></td></tr></table></figure>
<p><a href="https://github.com/google/oss-fuzz/blob/master/projects/boringssl/build.sh#L41" target="_blank" rel="external">创建种子集</a></p>
<h2 id="Reproducing-OSS-Fuzz-issues"><a href="#Reproducing-OSS-Fuzz-issues" class="headerlink" title="Reproducing OSS-Fuzz issues"></a>Reproducing OSS-Fuzz issues</h2><ul>
<li><p>reproduce issue<br>  不使用docker的方法：  </p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./fuzz_target_binary <span class="tag">&lt;<span class="name">testcase_path</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  使用docker的方法：</p>
  <figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">python</span> infra/helper.<span class="keyword">py</span> build_fuzzers $PROJECT_NAME <span class="symbol">&lt;source_path&gt;</span></div><div class="line"><span class="keyword">python</span> infra/helper.<span class="keyword">py</span> reproduce $PROJECT_NAME <span class="symbol">&lt;fuzzer_name&gt;</span> <span class="symbol">&lt;testcase_path&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>Fix issue</p>
</li>
<li>Submit fix：ClusterFuzz自动确认。</li>
</ul>
<h1 id="。。。。。。继续跟踪调研中。。。。。。。"><a href="#。。。。。。继续跟踪调研中。。。。。。。" class="headerlink" title="。。。。。。继续跟踪调研中。。。。。。。"></a>。。。。。。继续跟踪调研中。。。。。。。</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Driller:AugmentingFuzzingThroughSelectiveSymbolicExecution-阅读笔记]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/05/Driller-AugmentingFuzzingThroughSelectiveSymbolicExecution-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>简介：<br>Driller会对fuzzer感兴趣的路径进行符号执行，然后根据路径的条件，产生fuzzer无法满足的输入。  </p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><hr>
<p>自动化的漏洞分析工具大概可分为三类</p>
<ul>
<li><strong>static analysis system</strong><ul>
<li>cons：<ul>
<li>a large amount of false positives</li>
<li>cannot provide “actionable input”</li>
</ul>
</li>
</ul>
</li>
<li><strong>dynamic analysis system</strong>: such as “fuzzer”<ul>
<li>cons:<ul>
<li>need “input test cases” - considerable manual effort</li>
</ul>
</li>
</ul>
</li>
<li><strong>concolic analysis system</strong>: 利用了程序解释以及约束求解的方法产生输入<ul>
<li>cons:<ul>
<li>path explosion</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基于以上几点，进行总结：fuzzer随机产生输入，无法通过程序对输入的一些检测；concolic execution虽然能通过输入检测，但由于路径爆炸的问题，影响其能分析的程序深度。所以隐藏在深层逻辑中的缺陷难以被发现。</strong>  </p>
<p>考虑fuzzing和selective concolic execution结合。<br><strong>fuzzing —- within a compartment</strong><br><strong>selective concolic execution —-  between compartments</strong></p>
<p><strong>so</strong>  </p>
<p><strong><em>fuzzing</em></strong> -&gt; <strong>initial compartment</strong> -&gt; <strong><em>concolic</em></strong> -&gt; <strong>next compartment</strong> -&gt; <strong><em>fuzzing</em></strong> -&gt; <strong>new compartment</strong>   </p>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><hr>
<ul>
<li>Guided Fuzzing<ul>
<li>Dowser</li>
<li>BuzzFuzz</li>
<li>Flayer</li>
</ul>
</li>
<li>Whitebox Fuzzing</li>
<li>Concolic Execution</li>
</ul>
<h1 id="Driller-Overview"><a href="#Driller-Overview" class="headerlink" title="Driller Overview"></a>Driller Overview</h1><p>Driller process two different classes of user input:</p>
<ul>
<li>general input: a wide range of values that can be valid</li>
<li>specific input: input that must take on one of a select few possible values.</li>
</ul>
<p><strong>Components of Driller</strong>  </p>
<ul>
<li><strong>Input test cases</strong>: 可有可无，但是有输入用例，可以加速初始模糊测试的阶段，将目标指向某compartments。</li>
<li><strong>fuzzing</strong>: 模糊测试引擎寻找第一个compartment，直到遇到第一个复杂的specific input的检查。fuzzing engine -&gt; “stuck”</li>
<li><strong>concolic execution</strong>: 通过fuzzing模块生成的用例，追踪fuzzing模块已经到达的路径，本模块使用约束求解来发现未知路径，通过求解结果构造新的输入用例。</li>
<li><strong>repeat</strong></li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown的使用-马克飞象]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/04/markdown%E4%BD%BF%E7%94%A8-%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="external">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="external">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<p>[TOC]</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="external">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="meta">... </span>prompt'''</div></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">e=&gt;end</div><div class="line">op=&gt;operation: My Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">语法</a>。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li>[x] 已完成事项</li>
<li>[ ] 待办事项1</li>
<li>[ ] 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="external">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="external">@GGock</a></li>
<li>邮箱：<a href="&#109;&#x61;&#105;&#108;&#116;&#x6f;&#x3a;&#x68;&#x75;&#115;&#116;&#x67;&#111;&#99;&#x6b;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;">&#x68;&#x75;&#115;&#116;&#x67;&#111;&#99;&#x6b;&#x40;&#x67;&#109;&#x61;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="external">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="external">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SYMFUZZ的系统实现]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/04/symfuzz%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="SYMFUZZ的系统实现"><a href="#SYMFUZZ的系统实现" class="headerlink" title="SYMFUZZ的系统实现"></a>SYMFUZZ的系统实现</h1><p>系统主要基于BAP，利用了PIN 进行二进制插桩。<br>系统由三部分构成：  </p>
<ul>
<li><strong>Symbolic Analysis</strong>: 输入<code>seed s</code>，计算得出<code>Mutational Ratios r</code><ul>
<li><strong>tainted-block optimization</strong>: 对每个被插桩的基本块，实现了轻量级的污点分析。为了减少符号分析的开销，没有被污点信息覆盖的基本块，符号执行时不考虑。</li>
<li><strong>JIT and PD caching</strong>: 为了提高性能，JIT存储最近使用的BAP ILs，PD存储当前计算出的post-dominator结点。</li>
<li><strong>set memorization</strong></li>
</ul>
</li>
<li><strong>Mutational Fuzzing</strong>: 基于<code>r</code>进行变异，并监控crash的产生，并使用了Floyd-Bentley算法来计算k-subset，时间复杂度O(k),空间复杂度O(k)。输入样本为Nbits。</li>
<li><strong>Safe Stack Hash</strong>: 取调用栈中最近的五个函数调用来计算hash值。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++类的赋值运算符=的重载、深拷贝、浅拷贝]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/03/C++%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>在面向对象程序设计中，对象间的相互拷贝和赋值是经常进行的操作。<br><strong>拷贝运算：</strong>如果对象在申明的同时马上进行的初始化操作，则称之为拷贝运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">;  </span></div><div class="line">class1 B=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时其实调用的<code>B(A)</code>这样的浅拷贝操作。<br><strong>赋值运算：</strong> 如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">; </span></div><div class="line">class1 B<span class="comment">;</span></div><div class="line"><span class="attribute">B</span>=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时实际调用的类的缺省赋值函数<code>B.operator=(A);</code>  </p>
<p><strong>不管是浅拷贝还是赋值运算，其都有缺省的定义。</strong>也就是说，即使我们不overload这两种operation,仍然可以运行。那么，我们到底需不需要overload这两种operation 呢？答案就是：一般，<strong>我们我们需要手动编写析构函数的类，都需要overload 拷贝函数和赋值运算符。</strong>  </p>
<h3 id="类的赋值运算符"><a href="#类的赋值运算符" class="headerlink" title="类的赋值运算符"></a>类的赋值运算符</h3><hr>
<h4 id="1-C-中对象的内存分配方式"><a href="#1-C-中对象的内存分配方式" class="headerlink" title="1.C++中对象的内存分配方式"></a>1.C++中对象的内存分配方式</h4><p>在C++中，对象的实例在编译的时候，就需要为其分配内存大小，因此，系统都是在stack上为其分配内存的。<strong>这一点和C#完全不同！</strong>千万记住：在C#中，所有类都是reference type,要创建类的实体，必须通过new在heap上为其分配空间，同时返回在stack上指向其地址的reference.<br>因此，在C++中，只要申明该实例，在程序编译后，就要为其分配相应的内存空间，至于实体内的各个域的值，就由其构造函数决定了。</p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	    A()&#123;</div><div class="line">	    &#125;</div><div class="line">	    A(<span class="keyword">int</span> id, <span class="keyword">char</span> *t_name)&#123;</div><div class="line">		    _id = id;</div><div class="line">		    name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(t_name) + <span class="number">1</span>];</div><div class="line">		    <span class="built_in">strcpy</span>(name, t_name);</div><div class="line">	    &#125;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">        <span class="keyword">char</span> *name;</div><div class="line">        <span class="keyword">int</span> _id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="string">"herengang"</span>)</span></span>;</div><div class="line">		A b;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<pre><code>在程序编译之后，a和b在stack上都被分配相应的内存大小（类里面的成员变量会因为情况不同存储在heap中）。只不过对象a的域都被初始化，而b则都为随机值。
</code></pre><h4 id="2-缺省情况下的赋值运算符"><a href="#2-缺省情况下的赋值运算符" class="headerlink" title="2. 缺省情况下的赋值运算符"></a>2. 缺省情况下的赋值运算符</h4><p>如果我们执行：<code>b=a;</code>则其执行的是缺省定义的缺省的赋值运算。所谓缺省的赋值运算，是指<strong>对象中的所有位于stack中的域，进行相应的复制</strong>。但是，如果对象有位于heap上的域的话，其不会为拷贝对象分配heap上的空间，而只是<strong>指向相同的heap上的同一个地址</strong>。上面的程序中<code>username</code>就是存储在heap上面的。</p>
<p>因此，对于缺省的赋值运算，如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会<strong>连续两次释放heap上的同一块内存区域</strong>，从而导致异常。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~A()&#123;        </div><div class="line">    <span class="keyword">delete</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-解决办法–重载（overload-赋值运算符"><a href="#3-解决办法–重载（overload-赋值运算符" class="headerlink" title="3.解决办法–重载（overload)赋值运算符"></a>3.解决办法–重载（overload)赋值运算符</h4><p>因此，对于对象的域在heap上分配内存的情况，我们必须重载赋值运算符。当对象间进行拷贝的时候，我们必须让不同对象的成员域指向其不同的heap地址–如果成员域属于heap的话。  </p>
<p>重载赋值运算符后的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;</div><div class="line">    &#125;</div><div class="line">    A(<span class="keyword">int</span> id,<span class="keyword">char</span> *t_name)&#123;</div><div class="line">        _id=id;</div><div class="line">        name=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(t_name)+<span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(name,t_name);</div><div class="line">    &#125;    </div><div class="line">    A&amp; <span class="keyword">operator</span> =(A&amp; a)&#123;  <span class="comment">//注意：此处一定要返回对象的引用，否则返回后其值立即消失！</span></div><div class="line">        <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">        <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">        name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    ~A()&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _id;</div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="string">"herengang"</span>)</span></span>;</div><div class="line">    A b;</div><div class="line">    b=a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样<code>a</code>、<code>b</code>两个实例的<code>name</code>就指向了heap上面不同的区域。<code>a</code>、<code>b</code>在退出相应作用域的时候，调用相应析构函数，然后释放分别属于不同heap空间的内存，程序正常结束。  </p>
<h5 id="references"><a href="#references" class="headerlink" title="references:"></a>references:</h5><p>类的深拷贝函数的重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    A(A &amp;a);<span class="comment">//重载拷贝函数</span></div><div class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;b);<span class="comment">//重载赋值函数</span></div><div class="line">    <span class="comment">//或者,也可以这样重载赋值运算符 void operator=(const A &amp;a);即不返回任何值。如果这样的话，他将不支持客户代买中的链式赋值</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _id;</div><div class="line">    <span class="keyword">char</span> *username;</div><div class="line">&#125;	</div><div class="line">A::A(A &amp;a)&#123;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">    <span class="built_in">strcpy</span>(username, a.usernam);</div><div class="line">&#125;</div><div class="line">A&amp; A::operaton=(<span class="keyword">const</span> A &amp;a)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;a) <span class="comment">// 如果不判断，释放后再赋值，就会出现严重的问题</span></div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> username;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">strcpy</span>(username, a.usernam);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;    </div><div class="line">&#125;</div><div class="line"><span class="comment">//另外一种写法：</span></div><div class="line"><span class="keyword">void</span> A::operation= (<span class="keyword">const</span> A &amp;a)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> username;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">strcpy</span>(username,a.usernam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实，从上可以看出，赋值运算符和拷贝函数很相似。只不过赋值函数最好有返回值（进行链式赋值），返回也最好是对象的引用（为什么不是对象本身呢？note2有讲解）， 而拷贝函数不需要返回任何。同时，赋值函数首先要释放掉对象自身的堆空间（如果需要的话），然后进行其他的operation.而拷贝函数不需要如此，因为<strong><em>对象此时还没有分配堆空间</em></strong>。</p>
<p><mark>note1:</mark><br><strong><em>不要按值向函数传递对象。</em></strong>如果对象有内部指针指向动态分配的堆内存，丝毫不要考虑把对象按值传递给函数，要按引用传递。并记住：若函数不能改变参数对象的状态和目标对象的状态，则要使用const修饰符!</p>
<p><mark>note2:</mark><br>问题：<br>    对于类的成员需要动态申请堆空间的类的对象，大家都知道，我们都最好要overload其赋值函数和拷贝函数。拷贝构造函数是没有任何返回类型的，这点毋庸置疑。 而赋值函数可以返回多种类型，例如以上讲的void,类本身class1，以及类的引用 class &amp;? 问，这几种赋值函数的返回各有什么异同？<br>答：1 如果赋值函数返回的是void ，我们知道，其唯一一点需要注意的是，其不支持链式赋值运算，即a=b=c这样是不允许的！<br>2 对于返回的是类对象本身，还是类对象的引用，其有着本质的区别！</p>
<h6 id="第一：如果其返回的是类对象本身。"><a href="#第一：如果其返回的是类对象本身。" class="headerlink" title="第一：如果其返回的是类对象本身。"></a>第一：如果其返回的是类对象本身。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A <span class="keyword">operator</span> =(A&amp; a)&#123;</div><div class="line">    <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">    name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">    <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其过程是这样的：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"herengnag"</span>)<span class="comment">;</span></div><div class="line">class1 B<span class="comment">;   </span></div><div class="line"><span class="attribute">B</span>=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>看似简单的赋值操作，其所有的过程如下：</p>
<ul>
<li>释放对象原来的堆资源</li>
<li>重新申请堆空间</li>
<li>拷贝源的值到对象的堆空间的值</li>
<li>创建临时对象（调用临时对象拷贝构造函数），将临时对象返回</li>
<li>临时对象结束，调用临时对象析构函数，释放临时对象堆内存  </li>
</ul>
<p><strong>但是，在这些步骤里面，如果第4步，我们没有overload 拷贝函数，也就是没有进行深拷贝。那么在进行第5步释放临时对象的heap 空间时，将释放掉的是和目标对象同一块的heap空间。这样当目标对象B作用域结束调用析构函数时，就会产生错误！！</strong></p>
<h6 id="第二：如果赋值运算符返回的是对象的引用"><a href="#第二：如果赋值运算符返回的是对象的引用" class="headerlink" title="第二：如果赋值运算符返回的是对象的引用."></a>第二：如果赋值运算符返回的是对象的引用.</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A&amp; <span class="keyword">operator</span> =(A&amp; a)&#123;</div><div class="line">    <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">    name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">    <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么其过程如下:  </p>
<ul>
<li>释放掉原来对象所占有的堆空间</li>
<li>申请一块新的堆内存</li>
<li>将源对象的堆内存的值copy给新的堆内存</li>
<li>返回源对象的引用</li>
<li>结束  </li>
</ul>
<p><strong>因此，如果赋值运算符返回的是对象引用，那么其不会调用类的拷贝构造函数，这是问题的关键所在！！</strong></p>
<p>完整代码如下：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"stdafx.h"</span></div><div class="line">#include <span class="string">"string.h"</span></div><div class="line">#include <span class="string">"stdlib.h"</span></div><div class="line">#include <span class="string">"assert.h"</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> complex&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> <span class="built_in">real</span>;</div><div class="line">    <span class="keyword">int</span> virt;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    complex()&#123;</div><div class="line">        <span class="built_in">real</span> = virt = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    complex(<span class="keyword">int</span> treal,<span class="keyword">int</span> tvirt)&#123;</div><div class="line">        <span class="built_in">real</span> = treal;</div><div class="line">        virt = tvirt;</div><div class="line">    &#125;</div><div class="line">    complex operator+(<span class="keyword">const</span> complex &amp;x)&#123;</div><div class="line">        <span class="built_in">real</span> += x.<span class="built_in">real</span>;</div><div class="line">        virt += x.virt;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    complex operator=(<span class="keyword">const</span> complex &amp;x)&#123;</div><div class="line">        <span class="keyword">return</span> complex(x.<span class="built_in">real</span>, x.virt);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;</div><div class="line">        m_username=NULL;</div><div class="line">        printf(<span class="string">"null constructor"</span>);</div><div class="line">    &#125;</div><div class="line">    A(<span class="built_in">char</span> *username)&#123;</div><div class="line">        <span class="keyword">int</span> len;</div><div class="line">        len = strlen(username);</div><div class="line">        m_username = <span class="keyword">new</span> <span class="built_in">char</span>[len+<span class="number">1</span>];  <span class="comment">//(char*)malloc(sizeof(len+1));</span></div><div class="line">        strcpy(m_username, username);</div><div class="line">        printf(<span class="string">""</span>nUsername <span class="keyword">is</span> %s<span class="string">"n"</span>, m_username);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    A(A &amp;a);</div><div class="line">    A operator=(A &amp;b);</div><div class="line">    <span class="keyword">int</span> test(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    virtual ~A()&#123;</div><div class="line">    <span class="comment">//    if(m_username)</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">delete</span> m_username;</div><div class="line">        printf(<span class="string">""</span>nA <span class="keyword">is</span> destructed<span class="string">"n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="built_in">char</span> *m_username;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">A::A(A &amp;a)&#123;</div><div class="line">    <span class="keyword">int</span> len = strlen(a.m_username);</div><div class="line">    <span class="keyword">this</span>-&gt;m_username = <span class="keyword">new</span> <span class="built_in">char</span>[len+<span class="number">2</span>];</div><div class="line">    strcpy(m_username, a.m_username);</div><div class="line">    strcat(m_username, <span class="string">"f"</span>);</div><div class="line">    printf(<span class="string">""</span>ndeep copy <span class="built_in">function</span><span class="string">");</span></div><div class="line">&#125;</div><div class="line">A A::operator=(A &amp;b)&#123;</div><div class="line">    if(m_username)</div><div class="line">        delete m_username;		</div><div class="line">    int len = strlen(b.m_username);</div><div class="line">    this-&gt;m_username = new char[len+1];</div><div class="line">    strcpy(m_username, b.m_username);</div><div class="line">    // printf("copied successfully!<span class="string">");</span></div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B:public A&#123;</div><div class="line">public:</div><div class="line">    B(char *username,char *password):A(username)&#123;</div><div class="line">        int len = strlen(password) + 1;</div><div class="line">        m_password = new char[len]; //(char *)malloc(sizeof(len));</div><div class="line">        strcpy(m_password, password);</div><div class="line">        printf("username:%s, password:%s<span class="string">"n"</span>, m_username, m_password);</div><div class="line">    &#125;</div><div class="line">    ~B()&#123;</div><div class="line">        <span class="keyword">delete</span> m_password;</div><div class="line">        printf(<span class="string">"B is destructed"</span>n<span class="string">");</span></div><div class="line">    &#125;</div><div class="line">protected:</div><div class="line">    char *m_password;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])&#123;</div><div class="line">    //B b("herengang<span class="string">","</span><span class="number">982135</span><span class="string">");</span></div><div class="line">    //A *a=&amp;b;</div><div class="line">    //delete a;</div><div class="line">    A a("haha<span class="string">");</span></div><div class="line">    A b;</div><div class="line"></div><div class="line">    printf("<span class="string">"nbegin to invoke copy function"</span>);</div><div class="line">    b = a;</div><div class="line">        </div><div class="line">    <span class="comment">//printf("%d", b.test(2));</span></div><div class="line">    <span class="comment">//complex x(1, 3), y(1, 4);</span></div><div class="line">    <span class="comment">//x = (x + y);</span></div><div class="line">    <span class="comment">//printf("%d, %d", x.real, x.virt);</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ELF动态装载123]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/02/ELF%E5%8A%A8%E6%80%81%E8%A3%85%E8%BD%BD123/</url>
      <content type="html"><![CDATA[<p>ELF执行文件由以下几部分构成:</p>
<ul>
<li>ELF头部</li>
<li>程序头部表和其对应的段</li>
<li>节区头部表和其对应的节</li>
</ul>
<p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节区。</p>
<ul>
<li><strong>.rel.plt</strong> -&gt; 函数重定位<mark>【记录了函数在.got.plt中的地址】</mark></li>
<li>.rel.dyn -&gt; 变量重定位</li>
<li>.got -&gt; 全局变量偏移表</li>
<li><strong>.got.plt</strong> -&gt; 全局函数偏移表</li>
<li>.plt -&gt; 过程链接表【过程链接表把位置独立的函数调用重定向到绝对位置】</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/11/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
