<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[SYMFUZZ的系统实现]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/04/symfuzz%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="SYMFUZZ的系统实现"><a href="#SYMFUZZ的系统实现" class="headerlink" title="SYMFUZZ的系统实现"></a>SYMFUZZ的系统实现</h1><p>系统主要基于BAP，利用了PIN 进行二进制插桩。<br>系统由三部分构成：  </p>
<ul>
<li><strong>Symbolic Analysis</strong>: 输入<code>seed s</code>，计算得出<code>Mutational Ratios r</code><ul>
<li><strong>tainted-block optimization</strong>: 对每个被插桩的基本块，实现了轻量级的污点分析。为了减少符号分析的开销，没有被污点信息覆盖的基本块，符号执行时不考虑。</li>
<li><strong>JIT and PD caching</strong>: 为了提高性能，JIT存储最近使用的BAP ILs，PD存储当前计算出的post-dominator结点。</li>
<li><strong>set memorization</strong></li>
</ul>
</li>
<li><strong>Mutational Fuzzing</strong>: 基于<code>r</code>进行变异，并监控crash的产生，并使用了Floyd-Bentley算法来计算k-subset，时间复杂度O(k),空间复杂度O(k)。输入样本为Nbits。</li>
<li><strong>Safe Stack Hash</strong>: 取调用栈中最近的五个函数调用来计算hash值。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++类的赋值运算符=的重载、深拷贝、浅拷贝]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/03/C++%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>在面向对象程序设计中，对象间的相互拷贝和赋值是经常进行的操作。<br><strong>拷贝运算：</strong>如果对象在申明的同时马上进行的初始化操作，则称之为拷贝运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">;  </span></div><div class="line">class1 B=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时其实调用的<code>B(A)</code>这样的浅拷贝操作。<br><strong>赋值运算：</strong> 如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>); </div><div class="line">class1 B;</div><div class="line">B=A;</div><div class="line">```   </div><div class="line"></div><div class="line">此时实际调用的类的缺省赋值函数`B.operator=(A);`  </div><div class="line"></div><div class="line">**不管是浅拷贝还是赋值运算，其都有缺省的定义。**也就是说，即使我们不overload这两种operation,仍然可以运行。那么，我们到底需不需要overload这两种operation 呢？答案就是：一般，**我们我们需要手动编写析构函数的类，都需要overload 拷贝函数和赋值运算符。**  </div><div class="line"></div><div class="line">### 类的赋值运算符</div><div class="line">---  </div><div class="line">#### <span class="number">1.</span>C++中对象的内存分配方式</div><div class="line">在C++中，对象的实例在编译的时候，就需要为其分配内存大小，因此，系统都是在stack上为其分配内存的。**这一点和C#完全不同！**千万记住：在C#中，所有类都是reference type,要创建类的实体，必须通过new在heap上为其分配空间，同时返回在stack上指向其地址的reference.  </div><div class="line">因此，在C++中，只要申明该实例，在程序编译后，就要为其分配相应的内存空间，至于实体内的各个域的值，就由其构造函数决定了。</div><div class="line"></div><div class="line">例如:</div></pre></td></tr></table></figure></p>
<p>class A{<br>    public:<br>        A(){<br>        }<br>        A(int id, char <em>t_name){<br>            _id = id;<br>            name = new char[strlen(t_name) + 1];<br>            strcpy(name, t_name);<br>        }<br>    private:<br>        char </em>name;<br>        int _id;<br>    }</p>
<pre><code>int main(){
    A a(1, &quot;herengang&quot;);
    A b;
}
</code></pre><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">	在程序编译之后，a和b在stack上都被分配相应的内存大小（类里面的成员变量会因为情况不同存储在heap中）。只不过对象a的域都被初始化，而b则都为随机值。</div><div class="line">#### <span class="number">2.</span> 缺省情况下的赋值运算符  </div><div class="line">如果我们执行：`b=a;`则其执行的是缺省定义的缺省的赋值运算。所谓缺省的赋值运算，是指**对象中的所有位于stack中的域，进行相应的复制**。但是，如果对象有位于heap上的域的话，其不会为拷贝对象分配heap上的空间，而只是**指向相同的heap上的同一个地址**。上面的程序中`username`就是存储在heap上面的。</div><div class="line">  </div><div class="line">因此，对于缺省的赋值运算，如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会**连续两次释放heap上的同一块内存区域**，从而导致异常。</div></pre></td></tr></table></figure>
<p>~A(){<br>    delete name;<br>}<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#### <span class="number">3.</span>解决办法--重载（overload)赋值运算符  </div><div class="line">因此，对于对象的域在heap上分配内存的情况，我们必须重载赋值运算符。当对象间进行拷贝的时候，我们必须让不同对象的成员域指向其不同的heap地址--如果成员域属于heap的话。  </div><div class="line">  </div><div class="line">重载赋值运算符后的代码如下：</div></pre></td></tr></table></figure></p>
<p>class A{<br>public:<br>    A(){<br>    }<br>    A(int id,char <em>t_name){<br>        _id=id;<br>        name=new char[strlen(t_name)+1];<br>        strcpy(name,t_name);<br>    }<br>    A&amp; operator =(A&amp; a){  //注意：此处一定要返回对象的引用，否则返回后其值立即消失！<br>        if(name!=NULL)<br>        delete name;<br>        this-&gt;_id=a._id;<br>        int len=strlen(a.name);<br>        name=new char[len+1];<br>        strcpy(name,a.name);<br>        return </em>this;<br>    }<br>    ~A(){<br>        cout&lt;&lt;”~destructor”&lt;&lt;endl;<br>        delete name;<br>    }<br>private:<br>    int _id;<br>    char *name;<br>};</p>
<p>int main(){<br>    A a(1,”herengang”);<br>    A b;<br>    b=a;<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">这样`a`、`b`两个实例的`name`就指向了heap上面不同的区域。`a`、`b`在退出相应作用域的时候，调用相应析构函数，然后释放分别属于不同heap空间的内存，程序正常结束。  </div><div class="line"></div><div class="line">##### references:</div><div class="line">类的深拷贝函数的重载：</div></pre></td></tr></table></figure>
<p>public class A{<br>public:<br>    …<br>    A(A &amp;a);//重载拷贝函数<br>    A&amp; operator=(const A &amp;b);//重载赋值函数<br>    //或者,也可以这样重载赋值运算符 void operator=(const A &amp;a);即不返回任何值。如果这样的话，他将不支持客户代买中的链式赋值<br>private:<br>    int _id;<br>    char <em>username;<br>}<br>A::A(A &amp;a){<br>    _id = a._id;<br>    username = new char[strlen(a.username) + 1];<br>    if(username != NULL)<br>    strcpy(username, a.usernam);<br>}<br>A&amp; A::operaton=(const A &amp;a){<br>    if(this == &amp;a) // 如果不判断，释放后再赋值，就会出现严重的问题<br>        return </em>this;<br>    if(username != NULL)<br>        delete username;<br>    _id = a._id;<br>    username = new char[strlen(a.username) + 1];<br>    if(username != NULL)<br>        strcpy(username, a.usernam);<br>    return *this;<br>}<br>//另外一种写法：<br>void A::operation= (const A &amp;a)<br>{<br>    if(username != NULL)<br>        delete username;<br>    _id = a._id;<br>    username = new char[strlen(a.username) + 1];<br>    if(username != NULL)<br>        strcpy(username,a.usernam);<br>}</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">		</div><div class="line">其实，从上可以看出，赋值运算符和拷贝函数很相似。只不过赋值函数最好有返回值（进行链式赋值），返回也最好是对象的引用（为什么不是对象本身呢？note2有讲解）， 而拷贝函数不需要返回任何。同时，赋值函数首先要释放掉对象自身的堆空间（如果需要的话），然后进行其他的operation.而拷贝函数不需要如此，因为***对象此时还没有分配堆空间***。</div><div class="line"></div><div class="line">&lt;mark&gt;note1:&lt;/mark&gt;  </div><div class="line">***不要按值向函数传递对象。***如果对象有内部指针指向动态分配的堆内存，丝毫不要考虑把对象按值传递给函数，要按引用传递。并记住：若函数不能改变参数对象的状态和目标对象的状态，则要使用const修饰符!</div><div class="line"></div><div class="line">&lt;mark&gt;note2:&lt;/mark&gt;  </div><div class="line">问题：  </div><div class="line">	对于类的成员需要动态申请堆空间的类的对象，大家都知道，我们都最好要overload其赋值函数和拷贝函数。拷贝构造函数是没有任何返回类型的，这点毋庸置疑。 而赋值函数可以返回多种类型，例如以上讲的void,类本身class1，以及类的引用 <span class="keyword">class</span> &amp;? 问，这几种赋值函数的返回各有什么异同？</div><div class="line">答：<span class="number">1</span> 如果赋值函数返回的是void ，我们知道，其唯一一点需要注意的是，其不支持链式赋值运算，即a=b=c这样是不允许的！</div><div class="line"><span class="number">2</span> 对于返回的是类对象本身，还是类对象的引用，其有着本质的区别！</div><div class="line">###### 第一：如果其返回的是类对象本身。</div></pre></td></tr></table></figure>
<p>A operator =(A&amp; a){<br>    if(name!=NULL)<br>        delete name;<br>    this-&gt;_id=a._id;<br>    int len=strlen(a.name);<br>    name=new char[len+1];<br>    strcpy(name,a.name);<br>    return *this;<br>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">	</div><div class="line">其过程是这样的：</div></pre></td></tr></table></figure></p>
<p>class1 A(“herengnag”);<br>class1 B;<br>B=A;<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="code">	    </span></div><div class="line">看似简单的赋值操作，其所有的过程如下：</div><div class="line"></div><div class="line"><span class="bullet">* </span>释放对象原来的堆资源</div><div class="line"><span class="bullet">* </span>重新申请堆空间</div><div class="line"><span class="bullet">* </span>拷贝源的值到对象的堆空间的值</div><div class="line"><span class="bullet">* </span>创建临时对象（调用临时对象拷贝构造函数），将临时对象返回</div><div class="line"><span class="bullet">* </span>临时对象结束，调用临时对象析构函数，释放临时对象堆内存  </div><div class="line"></div><div class="line"><span class="strong">**但是，在这些步骤里面，如果第4步，我们没有overload 拷贝函数，也就是没有进行深拷贝。那么在进行第5步释放临时对象的heap 空间时，将释放掉的是和目标对象同一块的heap空间。这样当目标对象B作用域结束调用析构函数时，就会产生错误！！**</span></div><div class="line"></div><div class="line"><span class="section">###### 第二：如果赋值运算符返回的是对象的引用.</span></div></pre></td></tr></table></figure></p>
<p>A&amp; operator =(A&amp; a){<br>    if(name!=NULL)<br>        delete name;<br>    this-&gt;_id=a._id;<br>    int len=strlen(a.name);<br>    name=new char[len+1];<br>    strcpy(name,a.name);<br>    return *this;<br>}<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="code">		</span></div><div class="line">那么其过程如下:  </div><div class="line"></div><div class="line"><span class="bullet">* </span>释放掉原来对象所占有的堆空间</div><div class="line"><span class="bullet">* </span>申请一块新的堆内存</div><div class="line"><span class="bullet">* </span>将源对象的堆内存的值copy给新的堆内存</div><div class="line"><span class="bullet">* </span>返回源对象的引用</div><div class="line"><span class="bullet">* </span>结束  </div><div class="line"></div><div class="line">*<span class="strong">*因此，如果赋值运算符返回的是对象引用，那么其不会调用类的拷贝构造函数，这是问题的关键所在！！*</span>*</div><div class="line"></div><div class="line"></div><div class="line">完整代码如下：</div></pre></td></tr></table></figure></p>
<p>#include “stdafx.h”</p>
<p>#include “string.h”</p>
<p>#include “stdlib.h”</p>
<p>#include “assert.h”</p>
<p>class complex{<br>public:<br>    int real;<br>    int virt;<br>public:<br>    complex(){<br>        real = virt = 0;<br>    }<br>    complex(int treal,int tvirt){<br>        real = treal;<br>        virt = tvirt;<br>    }<br>    complex operator+(const complex &amp;x){<br>        real += x.real;<br>        virt += x.virt;<br>        return *this;<br>    }<br>    complex operator=(const complex &amp;x){<br>        return complex(x.real, x.virt);<br>    }<br>};</p>
<p>class A{<br>public:<br>    A(){<br>        m_username=NULL;<br>        printf(“null constructor”);<br>    }<br>    A(char <em>username){<br>        int len;<br>        len = strlen(username);<br>        m_username = new char[len+1];  //(char</em>)malloc(sizeof(len+1));<br>        strcpy(m_username, username);<br>        printf(“”nUsername is %s”n”, m_username);<br>    }</p>
<pre><code>A(A &amp;a);
A operator=(A &amp;b);
int test(const int &amp;x){
    return x;
}

virtual ~A(){
//    if(m_username)
    {
    delete m_username;
    printf(&quot;&quot;nA is destructed&quot;n&quot;);
    }
}
</code></pre><p>protected:<br>    char *m_username;</p>
<p>};<br>A::A(A &amp;a){<br>    int len = strlen(a.m_username);<br>    this-&gt;m_username = new char[len+2];<br>    strcpy(m_username, a.m_username);<br>    strcat(m_username, “f”);<br>    printf(“”ndeep copy function”);<br>}<br>A A::operator=(A &amp;b){<br>    if(m_username)<br>        delete m_username;<br>    int len = strlen(b.m_username);<br>    this-&gt;m_username = new char[len+1];<br>    strcpy(m_username, b.m_username);<br>    // printf(“copied successfully!”);<br>    return *this;<br>}</p>
<p>class B:public A{<br>public:<br>    B(char <em>username,char </em>password):A(username){<br>        int len = strlen(password) + 1;<br>        m_password = new char[len]; //(char <em>)malloc(sizeof(len));<br>        strcpy(m_password, password);<br>        printf(“username:%s, password:%s”n”, m_username, m_password);<br>    }<br>    ~B(){<br>        delete m_password;<br>        printf(“B is destructed”n”);<br>    }<br>protected:<br>    char </em>m_password;<br>};</p>
<p>int main(int argc, char<em> argv[]){<br>    //B b(“herengang”,”982135”);<br>    //A </em>a=&b;<br>    //delete a;<br>    A a(“haha”);<br>    A b;</p>
<pre><code>printf(&quot;&quot;nbegin to invoke copy function&quot;);
b = a;

//printf(&quot;%d&quot;, b.test(2));
//complex x(1, 3), y(1, 4);
//x = (x + y);
//printf(&quot;%d, %d&quot;, x.real, x.virt);
return 0;
</code></pre><p>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ELF动态装载123]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/02/ELF%E5%8A%A8%E6%80%81%E8%A3%85%E8%BD%BD123/</url>
      <content type="html"><![CDATA[<p>ELF执行文件由以下几部分构成:</p>
<ul>
<li>ELF头部</li>
<li>程序头部表和其对应的段</li>
<li>节区头部表和其对应的节</li>
</ul>
<p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节区。</p>
<ul>
<li><strong>.rel.plt</strong> -&gt; 函数重定位<mark>【记录了函数在.got.plt中的地址】</mark></li>
<li>.rel.dyn -&gt; 变量重定位</li>
<li>.got -&gt; 全局变量偏移表</li>
<li><strong>.got.plt</strong> -&gt; 全局函数偏移表</li>
<li>.plt -&gt; 过程链接表【过程链接表把位置独立的函数调用重定向到绝对位置】</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/11/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
