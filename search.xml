<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[IDA学习笔记(1)]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/23/IDA%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<p>《未完待续。。。。》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OSS-FUZZ相关调研]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/14/OSS-FUZZ%E7%9B%B8%E5%85%B3%E8%B0%83%E7%A0%94/</url>
      <content type="html"><![CDATA[<h1 id="第一次调研"><a href="#第一次调研" class="headerlink" title="第一次调研"></a>第一次调研</h1><h2 id="OSS-Fuzz概况"><a href="#OSS-Fuzz概况" class="headerlink" title="OSS-Fuzz概况"></a>OSS-Fuzz概况</h2><p>OSS-Fuzz与<a href="https://www.coreinfrastructure.org/" target="_blank" rel="external">Core Infrastructure Initiative</a>合作，目标是希望利用模糊测试技术以及分布式执行技术使开源软件更加安全可靠。<br>在OSS-Fuzz的第一阶段，开发者使用了带有Sanitizer的LibFuzzer，目前OSS-Fuzz仅支持C和C++语言。  </p>
<h3 id="Process-Overview"><a href="#Process-Overview" class="headerlink" title="Process Overview"></a>Process Overview</h3><p>OSS-Fuzz的整个流程如下：</p>
<ul>
<li>开源项目的维护这创建一个或多个fuzz target（也就是LibFuzzer中必须重载的LLVMFuzzerTestOneInput函数），并使用OSS-Fuzz项目中的创建及测试系统对它们进行<a href="https://github.com/google/oss-fuzz/blob/master/docs/ideal_integration.md" target="_blank" rel="external">整合</a>，构建出一个待测项目。</li>
<li>OSS-Fuzz接收待测项目。</li>
<li>当ClusterFuzz发现bug后，一个issue将在OSS-Fuzz的<a href="https://bugs.chromium.org/p/oss-fuzz/issues/list" target="_blank" rel="external">issue tracker</a>上面进行公布。Project owners are <strong>CC-ed</strong> to the bug report.</li>
<li>维护者修复bug。</li>
<li>ClusterFuzz自动确认已修复的bug，添加评注并关闭issue。</li>
<li>修复的7天后将被verified，90天后将会公布出来。  </li>
</ul>
<h2 id="Announcing-OSS-Fuzz-Continuous-fuzzing-for-open-source-software"><a href="#Announcing-OSS-Fuzz-Continuous-fuzzing-for-open-source-software" class="headerlink" title="Announcing OSS-Fuzz: Continuous fuzzing for open source software"></a>Announcing OSS-Fuzz: Continuous fuzzing for open source software</h2><p><a href="https://opensource.googleblog.com/2016/12/announcing-oss-fuzz-continuous-fuzzing.html" target="_blank" rel="external">参考链接</a> </p>
<blockquote>
<p>In recent years, several efficient general purpose fuzzing engines have been implemented (e.g. AFL and libFuzzer), and we use them to fuzz various components of the Chrome browser. These fuzzers, when combined with <strong>Sanitizers</strong>, can help find <strong>security vulnerabilities</strong> (e.g. buffer overflows, use-after-free, bad casts, integer overflows, etc), <strong>stability bugs</strong> (e.g. null dereferences, memory leaks, out-of-memory, assertion failures, etc) and sometimes even <strong>logical bugs</strong>.  </p>
</blockquote>
<p>文中说<a href="https://github.com/google/oss-fuzz" target="_blank" rel="external">OSS-Fuzz</a>将包含多种多样的模糊测试引擎（一开始是LibFuzzer），以及各种Sanitizers（一开始是AddressSanitizer），并且提供了一个由<a href="https://github.com/google/oss-fuzz/blob/master/docs/clusterfuzz.md" target="_blank" rel="external">ClusterFuzz</a>组成的大规模分布式执行环境。  </p>
<p><mark><strong><em>这里简介一下ClusterFuzz：</em></strong></mark><br>ClusterFuzz是位于OSS-Fuzz的后端，一开始是为了规模化的测试Chrome用的。ClusterFuzz将提供（貌似开发工作正在进行中）一个web interface来查看目标程序的测试情况（如：速度、覆盖信息、内存使用情况、crash信息）。<br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/freetype_stats.png" alt="fuzzer states">  </p>
<p>提供的coverage报告会中还会高亮标记源代码中覆盖到的语句。<br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/freetype_coverage_1.png" alt="coverage report 1">  </p>
<p>高亮标记<br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/freetype_coverage_2.png" alt="coverage report 2">  </p>
<p>crash报告中，含有stack trace、导致crash的样本、bug有可能发生的位置等。<br><img src="https://raw.githubusercontent.com/google/oss-fuzz/master/docs/images/pcre2_testcase.png" alt="crash report"></p>
<h3 id="Early-successes"><a href="#Early-successes" class="headerlink" title="Early successes"></a>Early successes</h3><p>这一部分讲述了开发者使用OSS-FUZZ得到了很好的结果，开发者的其中一个测试目标为<a href="https://www.freetype.org/" target="_blank" rel="external">FreeType</a>，开发者构建了一个<a href="http://git.savannah.gnu.org/cgit/freetype/freetype2.git/tree/src/tools/ftfuzzer/ftfuzzer.cc" target="_blank" rel="external">FreeTypeFuzzer</a>仅在源代码更新后的几个小时之内就发现了一个新的heap buffer overflow的漏洞。之后OSS-Fuzz通知相关的漏洞修补人员，最后OSS-Fuzz将自动的对修补后的结果进行确认。所有的过程在一天之内就完成了。  </p>
<h3 id="Contributions"><a href="#Contributions" class="headerlink" title="Contributions"></a>Contributions</h3><p>OSS-Fuzz已经发现了150个<a href="https://bugs.chromium.org/p/oss-fuzz/issues/list?can=1&amp;q=-component%3AInfra+-status%3ADuplicate%2CWontFix&amp;sort=-id&amp;colspec=ID+Type+Component+Status+Library+Reported+Owner+Summary&amp;cells=ids" target="_blank" rel="external">bug</a>（每周能产生4万亿个测试用例）。  </p>
<h1 id="。。。。。。继续跟踪调研中。。。。。。。"><a href="#。。。。。。继续跟踪调研中。。。。。。。" class="headerlink" title="。。。。。。继续跟踪调研中。。。。。。。"></a>。。。。。。继续跟踪调研中。。。。。。。</h1>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Driller:AugmentingFuzzingThroughSelectiveSymbolicExecution-阅读笔记]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/05/Driller-AugmentingFuzzingThroughSelectiveSymbolicExecution-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>简介：<br>Driller会对fuzzer感兴趣的路径进行符号执行，然后根据路径的条件，产生fuzzer无法满足的输入。  </p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><hr>
<p>自动化的漏洞分析工具大概可分为三类</p>
<ul>
<li><strong>static analysis system</strong><ul>
<li>cons：<ul>
<li>a large amount of false positives</li>
<li>cannot provide “actionable input”</li>
</ul>
</li>
</ul>
</li>
<li><strong>dynamic analysis system</strong>: such as “fuzzer”<ul>
<li>cons:<ul>
<li>need “input test cases” - considerable manual effort</li>
</ul>
</li>
</ul>
</li>
<li><strong>concolic analysis system</strong>: 利用了程序解释以及约束求解的方法产生输入<ul>
<li>cons:<ul>
<li>path explosion</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基于以上几点，进行总结：fuzzer随机产生输入，无法通过程序对输入的一些检测；concolic execution虽然能通过输入检测，但由于路径爆炸的问题，影响其能分析的程序深度。所以隐藏在深层逻辑中的缺陷难以被发现。</strong>  </p>
<p>考虑fuzzing和selective concolic execution结合。<br><strong>fuzzing —- within a compartment</strong><br><strong>selective concolic execution —-  between compartments</strong></p>
<p><strong>so</strong>  </p>
<p><strong><em>fuzzing</em></strong> -&gt; <strong>initial compartment</strong> -&gt; <strong><em>concolic</em></strong> -&gt; <strong>next compartment</strong> -&gt; <strong><em>fuzzing</em></strong> -&gt; <strong>new compartment</strong>   </p>
<h1 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h1><hr>
<ul>
<li>Guided Fuzzing<ul>
<li>Dowser</li>
<li>BuzzFuzz</li>
<li>Flayer</li>
</ul>
</li>
<li>Whitebox Fuzzing</li>
<li>Concolic Execution</li>
</ul>
<h1 id="Driller-Overview"><a href="#Driller-Overview" class="headerlink" title="Driller Overview"></a>Driller Overview</h1><p>Driller process two different classes of user input:</p>
<ul>
<li>general input: a wide range of values that can be valid</li>
<li>specific input: input that must take on one of a select few possible values.</li>
</ul>
<p><strong>Components of Driller</strong>  </p>
<ul>
<li><strong>Input test cases</strong>: 可有可无，但是有输入用例，可以加速初始模糊测试的阶段，将目标指向某compartments。</li>
<li><strong>fuzzing</strong>: 模糊测试引擎寻找第一个compartment，直到遇到第一个复杂的specific input的检查。fuzzing engine -&gt; “stuck”</li>
<li><strong>concolic execution</strong>: 通过fuzzing模块生成的用例，追踪fuzzing模块已经到达的路径，本模块使用约束求解来发现未知路径，通过求解结果构造新的输入用例。</li>
<li><strong>repeat</strong></li>
</ul>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown的使用-马克飞象]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/04/markdown%E4%BD%BF%E7%94%A8-%E9%A9%AC%E5%85%8B%E9%A3%9E%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h1 id="欢迎使用马克飞象"><a href="#欢迎使用马克飞象" class="headerlink" title="欢迎使用马克飞象"></a>欢迎使用马克飞象</h1><p>@(示例笔记本)[马克飞象|帮助|Markdown]</p>
<p><strong>马克飞象</strong>是一款专为印象笔记（Evernote）打造的Markdown编辑器，通过精心的设计与技术实现，配合印象笔记强大的存储和同步功能，带来前所未有的书写体验。特点概述：</p>
<ul>
<li><strong>功能丰富</strong> ：支持高亮代码块、<em>LaTeX</em> 公式、流程图，本地图片以及附件上传，甚至截图粘贴，工作学习好帮手；</li>
<li><strong>得心应手</strong> ：简洁高效的编辑器，提供<a href="http://maxiang.info/client_zh" target="_blank" rel="external">桌面客户端</a>以及<a href="https://chrome.google.com/webstore/detail/kidnkfckhbdkfgbicccmdggmpgogehop" target="_blank" rel="external">离线Chrome App</a>，支持移动端 Web；</li>
<li><strong>深度整合</strong> ：支持选择笔记本和添加标签，支持从印象笔记跳转编辑，轻松管理。</li>
</ul>
<hr>
<p>[TOC]</p>
<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><blockquote>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。    —— <a href="https://zh.wikipedia.org/wiki/Markdown" target="_blank" rel="external">维基百科</a></p>
</blockquote>
<p>正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为<strong>粗体</strong>或者<em>斜体</em>，创建一个<a href="http://www.example.com" target="_blank" rel="external">链接</a>或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按<code>Ctrl + /</code>查看帮助。 </p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@requires_authorization</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">somefunc</span><span class="params">(param1=<span class="string">''</span>, param2=<span class="number">0</span>)</span>:</span></div><div class="line">    <span class="string">'''A docstring'''</span></div><div class="line">    <span class="keyword">if</span> param1 &gt; param2: <span class="comment"># interesting</span></div><div class="line">        <span class="keyword">print</span> <span class="string">'Greater'</span></div><div class="line">    <span class="keyword">return</span> (param2 - param1 + <span class="number">1</span>) <span class="keyword">or</span> <span class="keyword">None</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SomeClass</span>:</span></div><div class="line">    <span class="keyword">pass</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>message = <span class="string">'''interpreter</span></div><div class="line"><span class="meta">... </span>prompt'''</div></pre></td></tr></table></figure>
<h3 id="LaTeX-公式"><a href="#LaTeX-公式" class="headerlink" title="LaTeX 公式"></a>LaTeX 公式</h3><p>可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式：</p>
<p>$$    x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><table>
<thead>
<tr>
<th style="text-align:left">Item</th>
<th style="text-align:right">Value</th>
<th style="text-align:center">Qty</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Computer</td>
<td style="text-align:right">1600 USD</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">Phone</td>
<td style="text-align:right">12 USD</td>
<td style="text-align:center">12</td>
</tr>
<tr>
<td style="text-align:left">Pipe</td>
<td style="text-align:right">1 USD</td>
<td style="text-align:center">234</td>
</tr>
</tbody>
</table>
<h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">st=&gt;start: Start</div><div class="line">e=&gt;end</div><div class="line">op=&gt;operation: My Operation</div><div class="line">cond=&gt;condition: Yes or No?</div><div class="line"></div><div class="line">st-&gt;op-&gt;cond</div><div class="line">cond(yes)-&gt;e</div><div class="line">cond(no)-&gt;op</div></pre></td></tr></table></figure>
<p>以及时序图:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Alice-&gt;Bob: Hello Bob, how are you?</div><div class="line">Note right of Bob: Bob thinks</div><div class="line">Bob--&gt;Alice: I am good thanks!</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>提示：</strong>想了解更多，请查看<strong>流程图</strong><a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">语法</a>以及<strong>时序图</strong><a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">语法</a>。</p>
</blockquote>
<h3 id="复选框"><a href="#复选框" class="headerlink" title="复选框"></a>复选框</h3><p>使用 <code>- [ ]</code> 和 <code>- [x]</code> 语法可以创建复选框，实现 todo-list 等功能。例如：</p>
<ul>
<li>[x] 已完成事项</li>
<li>[ ] 待办事项1</li>
<li>[ ] 待办事项2</li>
</ul>
<blockquote>
<p><strong>注意：</strong>目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在<strong>马克飞象</strong>中修改 Markdown 原文才可生效。下个版本将会全面支持。</p>
</blockquote>
<h2 id="印象笔记相关"><a href="#印象笔记相关" class="headerlink" title="印象笔记相关"></a>印象笔记相关</h2><h3 id="笔记本和标签"><a href="#笔记本和标签" class="headerlink" title="笔记本和标签"></a>笔记本和标签</h3><p><strong>马克飞象</strong>增加了<code>@(笔记本)[标签A|标签B]</code>语法, 以选择笔记本和添加标签。 <strong>绑定账号后</strong>， 输入<code>(</code>自动会出现笔记本列表，请从中选择。</p>
<h3 id="笔记标题"><a href="#笔记标题" class="headerlink" title="笔记标题"></a>笔记标题</h3><p><strong>马克飞象</strong>会自动使用文档内出现的第一个标题作为笔记标题。例如本文，就是第一行的 <code>欢迎使用马克飞象</code>。</p>
<h3 id="快捷编辑"><a href="#快捷编辑" class="headerlink" title="快捷编辑"></a>快捷编辑</h3><p>保存在印象笔记中的笔记，右上角会有一个红色的编辑按钮，点击后会回到<strong>马克飞象</strong>中打开并编辑该笔记。</p>
<blockquote>
<p><strong>注意：</strong>目前用户在印象笔记中单方面做的任何修改，马克飞象是无法自动感知和更新的。所以请务必回到马克飞象编辑。</p>
</blockquote>
<h3 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h3><p><strong>马克飞象</strong>通过<strong>将Markdown原文以隐藏内容保存在笔记中</strong>的精妙设计，实现了对Markdown的存储和再次编辑。既解决了其他产品只是单向导出HTML的单薄，又规避了服务端存储Markdown带来的隐私安全问题。这样，服务端仅作为对印象笔记 API调用和数据转换之用。</p>
<blockquote>
<p><strong>隐私声明：用户所有的笔记数据，均保存在印象笔记中。马克飞象不存储用户的任何笔记数据。</strong></p>
</blockquote>
<h3 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h3><p><strong>马克飞象</strong>使用浏览器离线存储将内容实时保存在本地，不必担心网络断掉或浏览器崩溃。为了节省空间和避免冲突，已同步至印象笔记并且不再修改的笔记将删除部分本地缓存，不过依然可以随时通过<code>文档管理</code>打开。</p>
<blockquote>
<p><strong>注意：</strong>虽然浏览器存储大部分时候都比较可靠，但印象笔记作为专业云存储，更值得信赖。以防万一，<strong>请务必经常及时同步到印象笔记</strong>。</p>
</blockquote>
<h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>右侧系统菜单（快捷键<code>Ctrl + M</code>）的<code>设置</code>中，提供了界面字体、字号、自定义CSS、vim/emacs 键盘模式等高级选项。</p>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>帮助    <code>Ctrl + /</code><br>同步文档    <code>Ctrl + S</code><br>创建文档    <code>Ctrl + Alt + N</code><br>最大化编辑器    <code>Ctrl + Enter</code><br>预览文档 <code>Ctrl + Alt + Enter</code><br>文档管理    <code>Ctrl + O</code><br>系统菜单    <code>Ctrl + M</code> </p>
<p>加粗    <code>Ctrl + B</code><br>插入图片    <code>Ctrl + G</code><br>插入链接    <code>Ctrl + L</code><br>提升标题    <code>Ctrl + H</code></p>
<h2 id="关于收费"><a href="#关于收费" class="headerlink" title="关于收费"></a>关于收费</h2><p><strong>马克飞象</strong>为新用户提供 10 天的试用期，试用期过后需要<a href="maxiang.info/vip.html">续费</a>才能继续使用。未购买或者未及时续费，将不能同步新的笔记。之前保存过的笔记依然可以编辑。</p>
<h2 id="反馈与建议"><a href="#反馈与建议" class="headerlink" title="反馈与建议"></a>反馈与建议</h2><ul>
<li>微博：<a href="http://weibo.com/u/2788354117" target="_blank" rel="external">@马克飞象</a>，<a href="http://weibo.com/ggock" title="开发者个人账号" target="_blank" rel="external">@GGock</a></li>
<li>邮箱：<a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#58;&#x68;&#x75;&#x73;&#x74;&#103;&#111;&#99;&#107;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;">&#x68;&#x75;&#x73;&#x74;&#103;&#111;&#99;&#107;&#64;&#103;&#109;&#x61;&#105;&#108;&#46;&#x63;&#x6f;&#109;</a></li>
</ul>
<hr>
<p>感谢阅读这份帮助文档。请点击右上角，绑定印象笔记账号，开启全新的记录与分享体验吧。</p>
<p>[^demo]: 这是一个示例脚注。请查阅 <a href="https://github.com/fletcher/MultiMarkdown/wiki/MultiMarkdown-Syntax-Guide#footnotes" target="_blank" rel="external">MultiMarkdown 文档</a> 关于脚注的说明。 <strong>限制：</strong> 印象笔记的笔记内容使用 <a href="https://dev.yinxiang.com/doc/articles/enml.php" target="_blank" rel="external">ENML</a> 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致<code>脚注</code>和<code>TOC</code>无法正常点击。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SYMFUZZ的系统实现]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/04/symfuzz%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h1 id="SYMFUZZ的系统实现"><a href="#SYMFUZZ的系统实现" class="headerlink" title="SYMFUZZ的系统实现"></a>SYMFUZZ的系统实现</h1><p>系统主要基于BAP，利用了PIN 进行二进制插桩。<br>系统由三部分构成：  </p>
<ul>
<li><strong>Symbolic Analysis</strong>: 输入<code>seed s</code>，计算得出<code>Mutational Ratios r</code><ul>
<li><strong>tainted-block optimization</strong>: 对每个被插桩的基本块，实现了轻量级的污点分析。为了减少符号分析的开销，没有被污点信息覆盖的基本块，符号执行时不考虑。</li>
<li><strong>JIT and PD caching</strong>: 为了提高性能，JIT存储最近使用的BAP ILs，PD存储当前计算出的post-dominator结点。</li>
<li><strong>set memorization</strong></li>
</ul>
</li>
<li><strong>Mutational Fuzzing</strong>: 基于<code>r</code>进行变异，并监控crash的产生，并使用了Floyd-Bentley算法来计算k-subset，时间复杂度O(k),空间复杂度O(k)。输入样本为Nbits。</li>
<li><strong>Safe Stack Hash</strong>: 取调用栈中最近的五个函数调用来计算hash值。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C++类的赋值运算符=的重载、深拷贝、浅拷贝]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/03/C++%E7%B1%BB%E7%9A%84%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-%E7%9A%84%E9%87%8D%E8%BD%BD%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E3%80%81%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      <content type="html"><![CDATA[<p>在面向对象程序设计中，对象间的相互拷贝和赋值是经常进行的操作。<br><strong>拷贝运算：</strong>如果对象在申明的同时马上进行的初始化操作，则称之为拷贝运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">;  </span></div><div class="line">class1 B=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时其实调用的<code>B(A)</code>这样的浅拷贝操作。<br><strong>赋值运算：</strong> 如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">; </span></div><div class="line">class1 B<span class="comment">;</span></div><div class="line"><span class="attribute">B</span>=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时实际调用的类的缺省赋值函数<code>B.operator=(A);</code>  </p>
<p><strong>不管是浅拷贝还是赋值运算，其都有缺省的定义。</strong>也就是说，即使我们不overload这两种operation,仍然可以运行。那么，我们到底需不需要overload这两种operation 呢？答案就是：一般，<strong>我们我们需要手动编写析构函数的类，都需要overload 拷贝函数和赋值运算符。</strong>  </p>
<h3 id="类的赋值运算符"><a href="#类的赋值运算符" class="headerlink" title="类的赋值运算符"></a>类的赋值运算符</h3><hr>
<h4 id="1-C-中对象的内存分配方式"><a href="#1-C-中对象的内存分配方式" class="headerlink" title="1.C++中对象的内存分配方式"></a>1.C++中对象的内存分配方式</h4><p>在C++中，对象的实例在编译的时候，就需要为其分配内存大小，因此，系统都是在stack上为其分配内存的。<strong>这一点和C#完全不同！</strong>千万记住：在C#中，所有类都是reference type,要创建类的实体，必须通过new在heap上为其分配空间，同时返回在stack上指向其地址的reference.<br>因此，在C++中，只要申明该实例，在程序编译后，就要为其分配相应的内存空间，至于实体内的各个域的值，就由其构造函数决定了。</p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	    A()&#123;</div><div class="line">	    &#125;</div><div class="line">	    A(<span class="keyword">int</span> id, <span class="keyword">char</span> *t_name)&#123;</div><div class="line">		    _id = id;</div><div class="line">		    name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(t_name) + <span class="number">1</span>];</div><div class="line">		    <span class="built_in">strcpy</span>(name, t_name);</div><div class="line">	    &#125;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">        <span class="keyword">char</span> *name;</div><div class="line">        <span class="keyword">int</span> _id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="string">"herengang"</span>)</span></span>;</div><div class="line">		A b;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<pre><code>在程序编译之后，a和b在stack上都被分配相应的内存大小（类里面的成员变量会因为情况不同存储在heap中）。只不过对象a的域都被初始化，而b则都为随机值。
</code></pre><h4 id="2-缺省情况下的赋值运算符"><a href="#2-缺省情况下的赋值运算符" class="headerlink" title="2. 缺省情况下的赋值运算符"></a>2. 缺省情况下的赋值运算符</h4><p>如果我们执行：<code>b=a;</code>则其执行的是缺省定义的缺省的赋值运算。所谓缺省的赋值运算，是指<strong>对象中的所有位于stack中的域，进行相应的复制</strong>。但是，如果对象有位于heap上的域的话，其不会为拷贝对象分配heap上的空间，而只是<strong>指向相同的heap上的同一个地址</strong>。上面的程序中<code>username</code>就是存储在heap上面的。</p>
<p>因此，对于缺省的赋值运算，如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会<strong>连续两次释放heap上的同一块内存区域</strong>，从而导致异常。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~A()&#123;        </div><div class="line">    <span class="keyword">delete</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-解决办法–重载（overload-赋值运算符"><a href="#3-解决办法–重载（overload-赋值运算符" class="headerlink" title="3.解决办法–重载（overload)赋值运算符"></a>3.解决办法–重载（overload)赋值运算符</h4><p>因此，对于对象的域在heap上分配内存的情况，我们必须重载赋值运算符。当对象间进行拷贝的时候，我们必须让不同对象的成员域指向其不同的heap地址–如果成员域属于heap的话。  </p>
<p>重载赋值运算符后的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;</div><div class="line">    &#125;</div><div class="line">    A(<span class="keyword">int</span> id,<span class="keyword">char</span> *t_name)&#123;</div><div class="line">        _id=id;</div><div class="line">        name=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(t_name)+<span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(name,t_name);</div><div class="line">    &#125;    </div><div class="line">    A&amp; <span class="keyword">operator</span> =(A&amp; a)&#123;  <span class="comment">//注意：此处一定要返回对象的引用，否则返回后其值立即消失！</span></div><div class="line">        <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">        <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">        name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    ~A()&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _id;</div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="string">"herengang"</span>)</span></span>;</div><div class="line">    A b;</div><div class="line">    b=a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样<code>a</code>、<code>b</code>两个实例的<code>name</code>就指向了heap上面不同的区域。<code>a</code>、<code>b</code>在退出相应作用域的时候，调用相应析构函数，然后释放分别属于不同heap空间的内存，程序正常结束。  </p>
<h5 id="references"><a href="#references" class="headerlink" title="references:"></a>references:</h5><p>类的深拷贝函数的重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    A(A &amp;a);<span class="comment">//重载拷贝函数</span></div><div class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;b);<span class="comment">//重载赋值函数</span></div><div class="line">    <span class="comment">//或者,也可以这样重载赋值运算符 void operator=(const A &amp;a);即不返回任何值。如果这样的话，他将不支持客户代买中的链式赋值</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _id;</div><div class="line">    <span class="keyword">char</span> *username;</div><div class="line">&#125;	</div><div class="line">A::A(A &amp;a)&#123;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">    <span class="built_in">strcpy</span>(username, a.usernam);</div><div class="line">&#125;</div><div class="line">A&amp; A::operaton=(<span class="keyword">const</span> A &amp;a)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;a) <span class="comment">// 如果不判断，释放后再赋值，就会出现严重的问题</span></div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> username;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">strcpy</span>(username, a.usernam);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;    </div><div class="line">&#125;</div><div class="line"><span class="comment">//另外一种写法：</span></div><div class="line"><span class="keyword">void</span> A::operation= (<span class="keyword">const</span> A &amp;a)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> username;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">strcpy</span>(username,a.usernam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实，从上可以看出，赋值运算符和拷贝函数很相似。只不过赋值函数最好有返回值（进行链式赋值），返回也最好是对象的引用（为什么不是对象本身呢？note2有讲解）， 而拷贝函数不需要返回任何。同时，赋值函数首先要释放掉对象自身的堆空间（如果需要的话），然后进行其他的operation.而拷贝函数不需要如此，因为<strong><em>对象此时还没有分配堆空间</em></strong>。</p>
<p><mark>note1:</mark><br><strong><em>不要按值向函数传递对象。</em></strong>如果对象有内部指针指向动态分配的堆内存，丝毫不要考虑把对象按值传递给函数，要按引用传递。并记住：若函数不能改变参数对象的状态和目标对象的状态，则要使用const修饰符!</p>
<p><mark>note2:</mark><br>问题：<br>    对于类的成员需要动态申请堆空间的类的对象，大家都知道，我们都最好要overload其赋值函数和拷贝函数。拷贝构造函数是没有任何返回类型的，这点毋庸置疑。 而赋值函数可以返回多种类型，例如以上讲的void,类本身class1，以及类的引用 class &amp;? 问，这几种赋值函数的返回各有什么异同？<br>答：1 如果赋值函数返回的是void ，我们知道，其唯一一点需要注意的是，其不支持链式赋值运算，即a=b=c这样是不允许的！<br>2 对于返回的是类对象本身，还是类对象的引用，其有着本质的区别！</p>
<h6 id="第一：如果其返回的是类对象本身。"><a href="#第一：如果其返回的是类对象本身。" class="headerlink" title="第一：如果其返回的是类对象本身。"></a>第一：如果其返回的是类对象本身。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A <span class="keyword">operator</span> =(A&amp; a)&#123;</div><div class="line">    <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">    name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">    <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其过程是这样的：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"herengnag"</span>)<span class="comment">;</span></div><div class="line">class1 B<span class="comment">;   </span></div><div class="line"><span class="attribute">B</span>=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>看似简单的赋值操作，其所有的过程如下：</p>
<ul>
<li>释放对象原来的堆资源</li>
<li>重新申请堆空间</li>
<li>拷贝源的值到对象的堆空间的值</li>
<li>创建临时对象（调用临时对象拷贝构造函数），将临时对象返回</li>
<li>临时对象结束，调用临时对象析构函数，释放临时对象堆内存  </li>
</ul>
<p><strong>但是，在这些步骤里面，如果第4步，我们没有overload 拷贝函数，也就是没有进行深拷贝。那么在进行第5步释放临时对象的heap 空间时，将释放掉的是和目标对象同一块的heap空间。这样当目标对象B作用域结束调用析构函数时，就会产生错误！！</strong></p>
<h6 id="第二：如果赋值运算符返回的是对象的引用"><a href="#第二：如果赋值运算符返回的是对象的引用" class="headerlink" title="第二：如果赋值运算符返回的是对象的引用."></a>第二：如果赋值运算符返回的是对象的引用.</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A&amp; <span class="keyword">operator</span> =(A&amp; a)&#123;</div><div class="line">    <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">    name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">    <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么其过程如下:  </p>
<ul>
<li>释放掉原来对象所占有的堆空间</li>
<li>申请一块新的堆内存</li>
<li>将源对象的堆内存的值copy给新的堆内存</li>
<li>返回源对象的引用</li>
<li>结束  </li>
</ul>
<p><strong>因此，如果赋值运算符返回的是对象引用，那么其不会调用类的拷贝构造函数，这是问题的关键所在！！</strong></p>
<p>完整代码如下：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"stdafx.h"</span></div><div class="line">#include <span class="string">"string.h"</span></div><div class="line">#include <span class="string">"stdlib.h"</span></div><div class="line">#include <span class="string">"assert.h"</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> complex&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> <span class="built_in">real</span>;</div><div class="line">    <span class="keyword">int</span> virt;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    complex()&#123;</div><div class="line">        <span class="built_in">real</span> = virt = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    complex(<span class="keyword">int</span> treal,<span class="keyword">int</span> tvirt)&#123;</div><div class="line">        <span class="built_in">real</span> = treal;</div><div class="line">        virt = tvirt;</div><div class="line">    &#125;</div><div class="line">    complex operator+(<span class="keyword">const</span> complex &amp;x)&#123;</div><div class="line">        <span class="built_in">real</span> += x.<span class="built_in">real</span>;</div><div class="line">        virt += x.virt;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    complex operator=(<span class="keyword">const</span> complex &amp;x)&#123;</div><div class="line">        <span class="keyword">return</span> complex(x.<span class="built_in">real</span>, x.virt);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;</div><div class="line">        m_username=NULL;</div><div class="line">        printf(<span class="string">"null constructor"</span>);</div><div class="line">    &#125;</div><div class="line">    A(<span class="built_in">char</span> *username)&#123;</div><div class="line">        <span class="keyword">int</span> len;</div><div class="line">        len = strlen(username);</div><div class="line">        m_username = <span class="keyword">new</span> <span class="built_in">char</span>[len+<span class="number">1</span>];  <span class="comment">//(char*)malloc(sizeof(len+1));</span></div><div class="line">        strcpy(m_username, username);</div><div class="line">        printf(<span class="string">""</span>nUsername <span class="keyword">is</span> %s<span class="string">"n"</span>, m_username);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    A(A &amp;a);</div><div class="line">    A operator=(A &amp;b);</div><div class="line">    <span class="keyword">int</span> test(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    virtual ~A()&#123;</div><div class="line">    <span class="comment">//    if(m_username)</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">delete</span> m_username;</div><div class="line">        printf(<span class="string">""</span>nA <span class="keyword">is</span> destructed<span class="string">"n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="built_in">char</span> *m_username;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">A::A(A &amp;a)&#123;</div><div class="line">    <span class="keyword">int</span> len = strlen(a.m_username);</div><div class="line">    <span class="keyword">this</span>-&gt;m_username = <span class="keyword">new</span> <span class="built_in">char</span>[len+<span class="number">2</span>];</div><div class="line">    strcpy(m_username, a.m_username);</div><div class="line">    strcat(m_username, <span class="string">"f"</span>);</div><div class="line">    printf(<span class="string">""</span>ndeep copy <span class="built_in">function</span><span class="string">");</span></div><div class="line">&#125;</div><div class="line">A A::operator=(A &amp;b)&#123;</div><div class="line">    if(m_username)</div><div class="line">        delete m_username;		</div><div class="line">    int len = strlen(b.m_username);</div><div class="line">    this-&gt;m_username = new char[len+1];</div><div class="line">    strcpy(m_username, b.m_username);</div><div class="line">    // printf("copied successfully!<span class="string">");</span></div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B:public A&#123;</div><div class="line">public:</div><div class="line">    B(char *username,char *password):A(username)&#123;</div><div class="line">        int len = strlen(password) + 1;</div><div class="line">        m_password = new char[len]; //(char *)malloc(sizeof(len));</div><div class="line">        strcpy(m_password, password);</div><div class="line">        printf("username:%s, password:%s<span class="string">"n"</span>, m_username, m_password);</div><div class="line">    &#125;</div><div class="line">    ~B()&#123;</div><div class="line">        <span class="keyword">delete</span> m_password;</div><div class="line">        printf(<span class="string">"B is destructed"</span>n<span class="string">");</span></div><div class="line">    &#125;</div><div class="line">protected:</div><div class="line">    char *m_password;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])&#123;</div><div class="line">    //B b("herengang<span class="string">","</span><span class="number">982135</span><span class="string">");</span></div><div class="line">    //A *a=&amp;b;</div><div class="line">    //delete a;</div><div class="line">    A a("haha<span class="string">");</span></div><div class="line">    A b;</div><div class="line"></div><div class="line">    printf("<span class="string">"nbegin to invoke copy function"</span>);</div><div class="line">    b = a;</div><div class="line">        </div><div class="line">    <span class="comment">//printf("%d", b.test(2));</span></div><div class="line">    <span class="comment">//complex x(1, 3), y(1, 4);</span></div><div class="line">    <span class="comment">//x = (x + y);</span></div><div class="line">    <span class="comment">//printf("%d, %d", x.real, x.virt);</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ELF动态装载123]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/12/02/ELF%E5%8A%A8%E6%80%81%E8%A3%85%E8%BD%BD123/</url>
      <content type="html"><![CDATA[<p>ELF执行文件由以下几部分构成:</p>
<ul>
<li>ELF头部</li>
<li>程序头部表和其对应的段</li>
<li>节区头部表和其对应的节</li>
</ul>
<p>如果一个可执行文件参与动态链接，它的程序头部表将包含类型为PT_DYNAMIC的段，它包含.dynamic节区。</p>
<ul>
<li><strong>.rel.plt</strong> -&gt; 函数重定位<mark>【记录了函数在.got.plt中的地址】</mark></li>
<li>.rel.dyn -&gt; 变量重定位</li>
<li>.got -&gt; 全局变量偏移表</li>
<li><strong>.got.plt</strong> -&gt; 全局函数偏移表</li>
<li>.plt -&gt; 过程链接表【过程链接表把位置独立的函数调用重定向到绝对位置】</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://mayfeelyang.github.io/MyBlog/2016/11/26/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
