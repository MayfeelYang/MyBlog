<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录生活点滴"><title>C++类的赋值运算符=的重载、深拷贝、浅拷贝 | 菜鸟の日常</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/MyBlog/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/MyBlog/favicon.ico"><link rel="apple-touch-icon" href="/MyBlog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/MyBlog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C++类的赋值运算符=的重载、深拷贝、浅拷贝</h1><a id="logo" href="/MyBlog/.">菜鸟の日常</a><p class="description">呆到深处自然萌~</p></div><div id="nav-menu"><a href="/MyBlog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/MyBlog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/MyBlog/about/"><i class="fa fa-user"> 关于</i></a><a href="/MyBlog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++类的赋值运算符=的重载、深拷贝、浅拷贝</h1><div class="post-meta">Dec 3, 2016<span> | </span><span class="category"><a href="/MyBlog/categories/Preparation-编程基础/">Preparation - 编程基础</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#类的赋值运算符"><span class="toc-number">1.</span> <span class="toc-text">类的赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C-中对象的内存分配方式"><span class="toc-number">1.1.</span> <span class="toc-text">1.C++中对象的内存分配方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-缺省情况下的赋值运算符"><span class="toc-number">1.2.</span> <span class="toc-text">2. 缺省情况下的赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-解决办法–重载（overload-赋值运算符"><span class="toc-number">1.3.</span> <span class="toc-text">3.解决办法–重载（overload)赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#references"><span class="toc-number">1.3.1.</span> <span class="toc-text">references:</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#第一：如果其返回的是类对象本身。"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">第一：如果其返回的是类对象本身。</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#第二：如果赋值运算符返回的是对象的引用"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">第二：如果赋值运算符返回的是对象的引用.</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>在面向对象程序设计中，对象间的相互拷贝和赋值是经常进行的操作。<br><strong>拷贝运算：</strong>如果对象在申明的同时马上进行的初始化操作，则称之为拷贝运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">;  </span></div><div class="line">class1 B=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时其实调用的<code>B(A)</code>这样的浅拷贝操作。<br><strong>赋值运算：</strong> 如果对象在申明之后，在进行的赋值运算，我们称之为赋值运算。例如：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"af"</span>)<span class="comment">; </span></div><div class="line">class1 B<span class="comment">;</span></div><div class="line"><span class="attribute">B</span>=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>此时实际调用的类的缺省赋值函数<code>B.operator=(A);</code>  </p>
<p><strong>不管是浅拷贝还是赋值运算，其都有缺省的定义。</strong>也就是说，即使我们不overload这两种operation,仍然可以运行。那么，我们到底需不需要overload这两种operation 呢？答案就是：一般，<strong>我们我们需要手动编写析构函数的类，都需要overload 拷贝函数和赋值运算符。</strong>  </p>
<h3 id="类的赋值运算符"><a href="#类的赋值运算符" class="headerlink" title="类的赋值运算符"></a>类的赋值运算符</h3><hr>
<h4 id="1-C-中对象的内存分配方式"><a href="#1-C-中对象的内存分配方式" class="headerlink" title="1.C++中对象的内存分配方式"></a>1.C++中对象的内存分配方式</h4><p>在C++中，对象的实例在编译的时候，就需要为其分配内存大小，因此，系统都是在stack上为其分配内存的。<strong>这一点和C#完全不同！</strong>千万记住：在C#中，所有类都是reference type,要创建类的实体，必须通过new在heap上为其分配空间，同时返回在stack上指向其地址的reference.<br>因此，在C++中，只要申明该实例，在程序编译后，就要为其分配相应的内存空间，至于实体内的各个域的值，就由其构造函数决定了。</p>
<p>例如:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line">	<span class="keyword">public</span>:</div><div class="line">	    A()&#123;</div><div class="line">	    &#125;</div><div class="line">	    A(<span class="keyword">int</span> id, <span class="keyword">char</span> *t_name)&#123;</div><div class="line">		    _id = id;</div><div class="line">		    name = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(t_name) + <span class="number">1</span>];</div><div class="line">		    <span class="built_in">strcpy</span>(name, t_name);</div><div class="line">	    &#125;</div><div class="line">	<span class="keyword">private</span>:</div><div class="line">        <span class="keyword">char</span> *name;</div><div class="line">        <span class="keyword">int</span> _id;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">		<span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>, <span class="string">"herengang"</span>)</span></span>;</div><div class="line">		A b;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<pre><code>在程序编译之后，a和b在stack上都被分配相应的内存大小（类里面的成员变量会因为情况不同存储在heap中）。只不过对象a的域都被初始化，而b则都为随机值。
</code></pre><h4 id="2-缺省情况下的赋值运算符"><a href="#2-缺省情况下的赋值运算符" class="headerlink" title="2. 缺省情况下的赋值运算符"></a>2. 缺省情况下的赋值运算符</h4><p>如果我们执行：<code>b=a;</code>则其执行的是缺省定义的缺省的赋值运算。所谓缺省的赋值运算，是指<strong>对象中的所有位于stack中的域，进行相应的复制</strong>。但是，如果对象有位于heap上的域的话，其不会为拷贝对象分配heap上的空间，而只是<strong>指向相同的heap上的同一个地址</strong>。上面的程序中<code>username</code>就是存储在heap上面的。</p>
<p>因此，对于缺省的赋值运算，如果对象域内没有heap上的空间，其不会产生任何问题。但是，如果对象域内需要申请heap上的空间，那么在析构对象的时候，就会<strong>连续两次释放heap上的同一块内存区域</strong>，从而导致异常。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">~A()&#123;        </div><div class="line">    <span class="keyword">delete</span> name;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="3-解决办法–重载（overload-赋值运算符"><a href="#3-解决办法–重载（overload-赋值运算符" class="headerlink" title="3.解决办法–重载（overload)赋值运算符"></a>3.解决办法–重载（overload)赋值运算符</h4><p>因此，对于对象的域在heap上分配内存的情况，我们必须重载赋值运算符。当对象间进行拷贝的时候，我们必须让不同对象的成员域指向其不同的heap地址–如果成员域属于heap的话。  </p>
<p>重载赋值运算符后的代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;</div><div class="line">    &#125;</div><div class="line">    A(<span class="keyword">int</span> id,<span class="keyword">char</span> *t_name)&#123;</div><div class="line">        _id=id;</div><div class="line">        name=<span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(t_name)+<span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(name,t_name);</div><div class="line">    &#125;    </div><div class="line">    A&amp; <span class="keyword">operator</span> =(A&amp; a)&#123;  <span class="comment">//注意：此处一定要返回对象的引用，否则返回后其值立即消失！</span></div><div class="line">        <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">        <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">        <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">        name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">        <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    ~A()&#123;</div><div class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"~destructor"</span>&lt;&lt;<span class="built_in">endl</span>;</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _id;</div><div class="line">    <span class="keyword">char</span> *name;</div><div class="line">&#125;;</div><div class="line">    </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>,<span class="string">"herengang"</span>)</span></span>;</div><div class="line">    A b;</div><div class="line">    b=a;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样<code>a</code>、<code>b</code>两个实例的<code>name</code>就指向了heap上面不同的区域。<code>a</code>、<code>b</code>在退出相应作用域的时候，调用相应析构函数，然后释放分别属于不同heap空间的内存，程序正常结束。  </p>
<h5 id="references"><a href="#references" class="headerlink" title="references:"></a>references:</h5><p>类的深拷贝函数的重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ...</div><div class="line">    A(A &amp;a);<span class="comment">//重载拷贝函数</span></div><div class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A &amp;b);<span class="comment">//重载赋值函数</span></div><div class="line">    <span class="comment">//或者,也可以这样重载赋值运算符 void operator=(const A &amp;a);即不返回任何值。如果这样的话，他将不支持客户代买中的链式赋值</span></div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _id;</div><div class="line">    <span class="keyword">char</span> *username;</div><div class="line">&#125;	</div><div class="line">A::A(A &amp;a)&#123;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">    <span class="built_in">strcpy</span>(username, a.usernam);</div><div class="line">&#125;</div><div class="line">A&amp; A::operaton=(<span class="keyword">const</span> A &amp;a)&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;a) <span class="comment">// 如果不判断，释放后再赋值，就会出现严重的问题</span></div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> username;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">strcpy</span>(username, a.usernam);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;    </div><div class="line">&#125;</div><div class="line"><span class="comment">//另外一种写法：</span></div><div class="line"><span class="keyword">void</span> A::operation= (<span class="keyword">const</span> A &amp;a)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> username;</div><div class="line">    _id = a._id;</div><div class="line">    username = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="built_in">strlen</span>(a.username) + <span class="number">1</span>];</div><div class="line">    <span class="keyword">if</span>(username != <span class="literal">NULL</span>)</div><div class="line">        <span class="built_in">strcpy</span>(username,a.usernam);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实，从上可以看出，赋值运算符和拷贝函数很相似。只不过赋值函数最好有返回值（进行链式赋值），返回也最好是对象的引用（为什么不是对象本身呢？note2有讲解）， 而拷贝函数不需要返回任何。同时，赋值函数首先要释放掉对象自身的堆空间（如果需要的话），然后进行其他的operation.而拷贝函数不需要如此，因为<strong><em>对象此时还没有分配堆空间</em></strong>。</p>
<p><mark>note1:</mark><br><strong><em>不要按值向函数传递对象。</em></strong>如果对象有内部指针指向动态分配的堆内存，丝毫不要考虑把对象按值传递给函数，要按引用传递。并记住：若函数不能改变参数对象的状态和目标对象的状态，则要使用const修饰符!</p>
<p><mark>note2:</mark><br>问题：<br>    对于类的成员需要动态申请堆空间的类的对象，大家都知道，我们都最好要overload其赋值函数和拷贝函数。拷贝构造函数是没有任何返回类型的，这点毋庸置疑。 而赋值函数可以返回多种类型，例如以上讲的void,类本身class1，以及类的引用 class &amp;? 问，这几种赋值函数的返回各有什么异同？<br>答：1 如果赋值函数返回的是void ，我们知道，其唯一一点需要注意的是，其不支持链式赋值运算，即a=b=c这样是不允许的！<br>2 对于返回的是类对象本身，还是类对象的引用，其有着本质的区别！</p>
<h6 id="第一：如果其返回的是类对象本身。"><a href="#第一：如果其返回的是类对象本身。" class="headerlink" title="第一：如果其返回的是类对象本身。"></a>第一：如果其返回的是类对象本身。</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A <span class="keyword">operator</span> =(A&amp; a)&#123;</div><div class="line">    <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">    name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">    <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其过程是这样的：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class1 A(<span class="string">"herengnag"</span>)<span class="comment">;</span></div><div class="line">class1 B<span class="comment">;   </span></div><div class="line"><span class="attribute">B</span>=A<span class="comment">;</span></div></pre></td></tr></table></figure></p>
<p>看似简单的赋值操作，其所有的过程如下：</p>
<ul>
<li>释放对象原来的堆资源</li>
<li>重新申请堆空间</li>
<li>拷贝源的值到对象的堆空间的值</li>
<li>创建临时对象（调用临时对象拷贝构造函数），将临时对象返回</li>
<li>临时对象结束，调用临时对象析构函数，释放临时对象堆内存  </li>
</ul>
<p><strong>但是，在这些步骤里面，如果第4步，我们没有overload 拷贝函数，也就是没有进行深拷贝。那么在进行第5步释放临时对象的heap 空间时，将释放掉的是和目标对象同一块的heap空间。这样当目标对象B作用域结束调用析构函数时，就会产生错误！！</strong></p>
<h6 id="第二：如果赋值运算符返回的是对象的引用"><a href="#第二：如果赋值运算符返回的是对象的引用" class="headerlink" title="第二：如果赋值运算符返回的是对象的引用."></a>第二：如果赋值运算符返回的是对象的引用.</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">A&amp; <span class="keyword">operator</span> =(A&amp; a)&#123;</div><div class="line">    <span class="keyword">if</span>(name!=<span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">delete</span> name;</div><div class="line">    <span class="keyword">this</span>-&gt;_id=a._id;</div><div class="line">    <span class="keyword">int</span> len=<span class="built_in">strlen</span>(a.name);</div><div class="line">    name=<span class="keyword">new</span> <span class="keyword">char</span>[len+<span class="number">1</span>];</div><div class="line">    <span class="built_in">strcpy</span>(name,a.name);</div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>那么其过程如下:  </p>
<ul>
<li>释放掉原来对象所占有的堆空间</li>
<li>申请一块新的堆内存</li>
<li>将源对象的堆内存的值copy给新的堆内存</li>
<li>返回源对象的引用</li>
<li>结束  </li>
</ul>
<p><strong>因此，如果赋值运算符返回的是对象引用，那么其不会调用类的拷贝构造函数，这是问题的关键所在！！</strong></p>
<p>完整代码如下：<br><figure class="highlight d"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line">#include <span class="string">"stdafx.h"</span></div><div class="line">#include <span class="string">"string.h"</span></div><div class="line">#include <span class="string">"stdlib.h"</span></div><div class="line">#include <span class="string">"assert.h"</span></div><div class="line"></div><div class="line"><span class="keyword">class</span> complex&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">int</span> <span class="built_in">real</span>;</div><div class="line">    <span class="keyword">int</span> virt;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    complex()&#123;</div><div class="line">        <span class="built_in">real</span> = virt = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    complex(<span class="keyword">int</span> treal,<span class="keyword">int</span> tvirt)&#123;</div><div class="line">        <span class="built_in">real</span> = treal;</div><div class="line">        virt = tvirt;</div><div class="line">    &#125;</div><div class="line">    complex operator+(<span class="keyword">const</span> complex &amp;x)&#123;</div><div class="line">        <span class="built_in">real</span> += x.<span class="built_in">real</span>;</div><div class="line">        virt += x.virt;</div><div class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    complex operator=(<span class="keyword">const</span> complex &amp;x)&#123;</div><div class="line">        <span class="keyword">return</span> complex(x.<span class="built_in">real</span>, x.virt);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> A&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    A()&#123;</div><div class="line">        m_username=NULL;</div><div class="line">        printf(<span class="string">"null constructor"</span>);</div><div class="line">    &#125;</div><div class="line">    A(<span class="built_in">char</span> *username)&#123;</div><div class="line">        <span class="keyword">int</span> len;</div><div class="line">        len = strlen(username);</div><div class="line">        m_username = <span class="keyword">new</span> <span class="built_in">char</span>[len+<span class="number">1</span>];  <span class="comment">//(char*)malloc(sizeof(len+1));</span></div><div class="line">        strcpy(m_username, username);</div><div class="line">        printf(<span class="string">""</span>nUsername <span class="keyword">is</span> %s<span class="string">"n"</span>, m_username);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    A(A &amp;a);</div><div class="line">    A operator=(A &amp;b);</div><div class="line">    <span class="keyword">int</span> test(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)&#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    virtual ~A()&#123;</div><div class="line">    <span class="comment">//    if(m_username)</span></div><div class="line">        &#123;</div><div class="line">        <span class="keyword">delete</span> m_username;</div><div class="line">        printf(<span class="string">""</span>nA <span class="keyword">is</span> destructed<span class="string">"n"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">protected</span>:</div><div class="line">    <span class="built_in">char</span> *m_username;</div><div class="line"></div><div class="line">&#125;;</div><div class="line">A::A(A &amp;a)&#123;</div><div class="line">    <span class="keyword">int</span> len = strlen(a.m_username);</div><div class="line">    <span class="keyword">this</span>-&gt;m_username = <span class="keyword">new</span> <span class="built_in">char</span>[len+<span class="number">2</span>];</div><div class="line">    strcpy(m_username, a.m_username);</div><div class="line">    strcat(m_username, <span class="string">"f"</span>);</div><div class="line">    printf(<span class="string">""</span>ndeep copy <span class="built_in">function</span><span class="string">");</span></div><div class="line">&#125;</div><div class="line">A A::operator=(A &amp;b)&#123;</div><div class="line">    if(m_username)</div><div class="line">        delete m_username;		</div><div class="line">    int len = strlen(b.m_username);</div><div class="line">    this-&gt;m_username = new char[len+1];</div><div class="line">    strcpy(m_username, b.m_username);</div><div class="line">    // printf("copied successfully!<span class="string">");</span></div><div class="line">    return *this;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class B:public A&#123;</div><div class="line">public:</div><div class="line">    B(char *username,char *password):A(username)&#123;</div><div class="line">        int len = strlen(password) + 1;</div><div class="line">        m_password = new char[len]; //(char *)malloc(sizeof(len));</div><div class="line">        strcpy(m_password, password);</div><div class="line">        printf("username:%s, password:%s<span class="string">"n"</span>, m_username, m_password);</div><div class="line">    &#125;</div><div class="line">    ~B()&#123;</div><div class="line">        <span class="keyword">delete</span> m_password;</div><div class="line">        printf(<span class="string">"B is destructed"</span>n<span class="string">");</span></div><div class="line">    &#125;</div><div class="line">protected:</div><div class="line">    char *m_password;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])&#123;</div><div class="line">    //B b("herengang<span class="string">","</span><span class="number">982135</span><span class="string">");</span></div><div class="line">    //A *a=&amp;b;</div><div class="line">    //delete a;</div><div class="line">    A a("haha<span class="string">");</span></div><div class="line">    A b;</div><div class="line"></div><div class="line">    printf("<span class="string">"nbegin to invoke copy function"</span>);</div><div class="line">    b = a;</div><div class="line">        </div><div class="line">    <span class="comment">//printf("%d", b.test(2));</span></div><div class="line">    <span class="comment">//complex x(1, 3), y(1, 4);</span></div><div class="line">    <span class="comment">//x = (x + y);</span></div><div class="line">    <span class="comment">//printf("%d, %d", x.real, x.virt);</span></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</div><script type="text/javascript" src="/MyBlog/js/share.js?v=0.0.0" async></script><a data-url="http://mayfeelyang.github.io/MyBlog/2016/12/03/C++类的赋值运算符-的重载、深拷贝、浅拷贝/" data-id="cix1hvk770000qfc0ihn7gw46" class="article-share-link">分享到</a><div class="tags"><a href="/MyBlog/tags/C/">C++</a></div><div class="post-nav"><a href="/MyBlog/2016/12/04/symfuzz的实现/" class="pre">SYMFUZZ的系统实现</a><a href="/MyBlog/2016/12/02/ELF动态装载123/" class="next">ELF动态装载123</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/CTF相关/">CTF相关</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/Preparation-编程基础/">Preparation - 编程基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/模糊测试/">模糊测试</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/MyBlog/tags/symbolic-execution/" style="font-size: 15px;">symbolic execution</a> <a href="/MyBlog/tags/C/" style="font-size: 15px;">C++</a> <a href="/MyBlog/tags/ELF/" style="font-size: 15px;">ELF</a> <a href="/MyBlog/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/MyBlog/tags/driller/" style="font-size: 15px;">driller</a> <a href="/MyBlog/tags/IDA/" style="font-size: 15px;">IDA</a> <a href="/MyBlog/tags/oss/" style="font-size: 15px;">oss</a> <a href="/MyBlog/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/MyBlog/tags/symfuzz/" style="font-size: 15px;">symfuzz</a> <a href="/MyBlog/tags/symbolic-analysis/" style="font-size: 15px;">symbolic analysis</a> <a href="/MyBlog/tags/BAP/" style="font-size: 15px;">BAP</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/23/IDA学习笔记-1/">IDA学习笔记(1)</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/14/OSS-FUZZ相关调研/">OSS-FUZZ相关调研</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/05/Driller-AugmentingFuzzingThroughSelectiveSymbolicExecution-阅读笔记/">Driller:AugmentingFuzzingThroughSelectiveSymbolicExecution-阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/04/markdown使用-马克飞象/">markdown的使用-马克飞象</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/04/symfuzz的实现/">SYMFUZZ的系统实现</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/03/C++类的赋值运算符-的重载、深拷贝、浅拷贝/">C++类的赋值运算符=的重载、深拷贝、浅拷贝</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/12/02/ELF动态装载123/">ELF动态装载123</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2016/11/26/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/MyBlog/." rel="nofollow">菜鸟の日常.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/MyBlog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/MyBlog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/MyBlog/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/MyBlog/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/MyBlog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/MyBlog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/MyBlog/js/smartresize.js?v=0.0.0"></script></div></body></html>