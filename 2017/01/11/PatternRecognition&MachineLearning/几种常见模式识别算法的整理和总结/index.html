<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="记录生活点滴"><title>几种常见模式识别算法的整理和总结 | 菜鸟の日常</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/MyBlog/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/MyBlog/favicon.ico"><link rel="apple-touch-icon" href="/MyBlog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/MyBlog/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">几种常见模式识别算法的整理和总结</h1><a id="logo" href="/MyBlog/.">菜鸟の日常</a><p class="description">呆到深处自然萌~</p></div><div id="nav-menu"><a href="/MyBlog/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/MyBlog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/MyBlog/about/"><i class="fa fa-user"> 关于</i></a><a href="/MyBlog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">几种常见模式识别算法的整理和总结</h1><div class="post-meta">Jan 11, 2017<span> | </span><span class="category"><a href="/MyBlog/categories/模式识别/">模式识别</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-K-Nearest-Neighbor"><span class="toc-number">1.</span> <span class="toc-text">1.K-Nearest Neighbor</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Bayes-Classifier"><span class="toc-number">2.</span> <span class="toc-text">2.Bayes Classifier</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Principle-Component-Analysis"><span class="toc-number">3.</span> <span class="toc-text">3.Principle Component Analysis</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Linear-Discriminant-Analysis"><span class="toc-number">4.</span> <span class="toc-text">4.Linear Discriminant Analysis</span></a></li></ol></div></div><div class="post-content"><h1 id="1-K-Nearest-Neighbor"><a href="#1-K-Nearest-Neighbor" class="headerlink" title="1.K-Nearest Neighbor"></a>1.K-Nearest Neighbor</h1><p>K-NN可以说是一种最直接的用来分类未知数据的方法。基本通过下面这张图跟文字说明就可以明白K-NN是干什么的<br><img src="/MyBlog/2017/01/11/PatternRecognition&MachineLearning/几种常见模式识别算法的整理和总结/h.png" alt="k-nn"><br>简单来说，K-NN可以看成：有那么一堆你已经知道分类的数据，然后当一个新数据进入的时候，就开始跟训练数据里的每个点求距离，然后挑离这个训练数据最近的K个点看看这几个点属于什么类型，然后用少数服从多数的原则，给新数据归类。一个比较好的介绍k-NN的课件可以见下面链接，图文并茂，我当时一看就懂了<br><a href="http://courses.cs.tamu.edu/rgutier/cs790_w02/l8.pdf" target="_blank" rel="external">http://courses.cs.tamu.edu/rgutier/cs790_w02/l8.pdf</a></p>
<p>实际上K-NN本身的运算量是相当大的，因为数据的维数往往不止2维，而且训练数据库越大，所求的样本间距离就越多。就拿我们course project的人脸检测来说，输入向量的维数是1024维(32x32的图，当然我觉得这种方法比较silly)，训练数据有上千个，所以每次求距离(这里用的是欧式距离，就是我们最常用的平方和开根号求距法) 这样每个点的归类都要花上上百万次的计算。所以现在比较常用的一种方法就是kd-tree。也就是把整个输入空间划分成很多很多小子区域，然后根据临近的原则把它们组织为树形结构。然后搜索最近K个点的时候就不用全盘比较而只要比较临近几个子区域的训练数据就行了。kd-tree的一个比较好的课件可以见下面链接：<br><a href="https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf" target="_blank" rel="external">https://www.cise.ufl.edu/class/cot5520fa09/CG_RangeKDtrees.pdf</a></p>
<p>当然，kd-tree有一个问题就是当输入维数跟训练数据数量很接近时就很难优化了。所以用PCA(稍后会介绍)降维大多数情况下是很有必要的</p>
<h1 id="2-Bayes-Classifier"><a href="#2-Bayes-Classifier" class="headerlink" title="2.Bayes Classifier"></a>2.Bayes Classifier</h1><p>贝叶斯方法一篇比较科普的中文介绍可以见pongba的平凡而神奇的贝叶斯方法: <mark><a href="http://mindhacks.cn/2008/09/21/the-magical-bayesian-method" target="_blank" rel="external">http://mindhacks.cn/2008/09/21/the-magical-bayesian-method/</a></mark>，实际实现一个贝叶斯分类器之后再回头看这篇文章，感觉就很不一样。  </p>
<p>在模式识别的实际应用中，贝叶斯方法绝非就是post正比于prior*likelihood这个公式这么简单，一般而言我们都会用正态分布拟合likelihood来实现。  </p>
<p>用正态分布拟合是什么意思呢？贝叶斯方法式子的右边有两个量，一个是prior先验概率，这个求起来很简单，就是一大堆数据中求某一类数据占的百分比就可以了，比如300个一堆的数据中A类数据占100个，那么A的先验概率就是1/3。第二个就是likelihood，likelihood可以这么理解：对于每一类的训练数据，我们都用一个multivariate正态分布来拟合它们(即通过求得某一分类训练数据的平均值和协方差矩阵来拟合出一个正态分布)，然后当进入一个新的测试数据之后，就分别求取这个数据点在每个类别的正态分布中的大小，然后用这个值乘以原先的prior便是所要求得的后验概率post了。  </p>
<p>贝叶斯公式中还有一个evidence，对于初学者来说，可能会一下没法理解为什么在实际运算中它不见了。实则上，evidence只是一个让最后post归一化的东西，而在模式分类中，我们只需要比较不同类别间post的大小，归一化反而增加了它的运算量。当然，在有的地方，这个evidence绝对不能省，比如后文提到的GMM中，需要用到EM迭代，这时候如果不用evidence将post归一化，后果就会很可怕。<br>Bayes方法一个不错的参考网页可见下面链接：<br><a href="http://www.cs.mcgill.ca/~mcleish/644/main.html" target="_blank" rel="external">http://www.cs.mcgill.ca/~mcleish/644/main.html</a></p>
<h1 id="3-Principle-Component-Analysis"><a href="#3-Principle-Component-Analysis" class="headerlink" title="3.Principle Component Analysis"></a>3.Principle Component Analysis</h1><p>PCA，译为主元分析或者主成份分析，是一种很好的简化数据的方法，也是PR中常见到不能再常见的算法之一。CSDN上有一篇很不错的中文博客介绍PCA，《主元分析(PCA)理论分析及应用》，可以见下面链接：<br><a href="http://blog.csdn.net/ayw_hehe/archive/2010/07/16/5736659.aspx" target="_blank" rel="external">http://blog.csdn.net/ayw_hehe/archive/2010/07/16/5736659.aspx</a><br>对于我而言，主元分析最大的意义就是让我明白了线性代数中特征值跟特征向量究竟代表什么，从而让我进一步感受到了线性代数的博大精深魅力无穷。- -|||</p>
<p>PCA简而言之就是根据输入数据的分布给输入数据重新找到更能描述这组数据的正交的坐标轴，比如对于那个椭圆状的分布，最方便表示这个分布的坐标轴肯定是椭圆的长轴短轴而不是原来的x y。</p>
<p>那么如何求出这个长轴和短轴呢？于是线性代数就来了：我们求出这堆数据的协方差矩阵(关于什么是协方差矩阵，详见本节最后附的链接)，然后再求出这个协方差矩阵的特征值和特征向量，对应最大特征值的那个特征向量的方向就是长轴(也就是主元)的方向，次大特征值的就是第二主元的方向，以此类推。</p>
<p>关于PCA，推荐两个不错的tutorial:<br>(1) A tutorial on Principle Component Analysis从最基本的数学原理到应用都有，让我在被老师的讲课弄晕之后瞬间开悟的tutorial:<a href="http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf" target="_blank" rel="external">http://www.cs.otago.ac.nz/cosc453/student_tutorials/principal_components.pdf</a><br>(2) 里面有一个很生动的实现PCA的例子，还有告诉你PCA跟SVD是什么关系的，对编程实现的帮助很大(当然大多数情况下都不用自己编了):<a href="http://www.math.ucsd.edu/~gptesler/283/pca_07-handout.pdf" target="_blank" rel="external">http://www.math.ucsd.edu/~gptesler/283/pca_07-handout.pdf</a>(不能使用)</p>
<h1 id="4-Linear-Discriminant-Analysis"><a href="#4-Linear-Discriminant-Analysis" class="headerlink" title="4.Linear Discriminant Analysis"></a>4.Linear Discriminant Analysis</h1><p>LDA，基本和PCA是一对双生子，它们之间的区别就是PCA是一种unsupervised的映射方法而LDA是一种supervised映射方法，这一点可以从下图中一个2D的例子简单看出</p>
<p><img src="/MyBlog/2017/01/11/PatternRecognition&MachineLearning/几种常见模式识别算法的整理和总结/114542_1292688413RtUs.png" alt="lda"></p>
<p>图的左边是PCA，它所作的只是将整组数据整体映射到最方便表示这组数据的坐标轴上，映射时没有利用任何数据内部的分类信息。因此，虽然做了PCA后，整组数据在表示上更加方便(降低了维数并将信息损失降到最低)，但在分类上也许会变得更加困难；图的右边是LDA，可以明显看出，在增加了分类信息之后，两组输入映射到了另外一个坐标轴上，有了这样一个映射，两组数据之间的就变得更易区分了(在低维上就可以区分，减少了很大的运算量)。</p>
<p>在实际应用中，最常用的一种LDA方法叫作Fisher Linear Discriminant，其简要原理就是求取一个线性变换，是的样本数据中“between classes scatter matrix”(不同类数据间的协方差矩阵)和“within classes scatter matrix”(同一类数据内部的各个数据间协方差矩阵)之比的达到最大。关于Fisher LDA更具体的内容可以见下面课件，写的很不错~</p>
<p><a href="http://www.csd.uwo.ca/~olga/Courses//CS434a_541a//Lecture8.pdf" target="_blank" rel="external">http://www.csd.uwo.ca/~olga/Courses//CS434a_541a//Lecture8.pdf</a> </p>
<p><br \=""><br><br \=""><br><br \=""><br><br \=""></p>
<p>转自<a href="http://blog.csdn.net/scyscyao/article/details/5987581" target="_blank" rel="external">http://blog.csdn.net/scyscyao/article/details/5987581</a></p>
</div><script type="text/javascript" src="/MyBlog/js/share.js?v=0.0.0" async></script><a data-url="http://mayfeelyang.github.io/MyBlog/2017/01/11/PatternRecognition&amp;MachineLearning/几种常见模式识别算法的整理和总结/" data-id="cj4w68ird002qvbc0ut9t2pue" class="article-share-link">分享到</a><div class="tags"><a href="/MyBlog/tags/模式识别/">模式识别</a></div><div class="post-nav"><a href="/MyBlog/2017/01/14/Libbpg-0-9-7-bpgdec-Heap-Buffer-Overflow-Vulnerability/" class="pre">Libbpg-0.9.7 (bpgdec) Heap Buffer Overflow Vulnerability</a><a href="/MyBlog/2016/12/23/IDA学习笔记-1/" class="next">IDA学习笔记(1)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/CTF相关/">CTF相关</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/Preparation-编程基础/">Preparation - 编程基础</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/web安全/">web安全</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/模式识别/">模式识别</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/模糊测试/">模糊测试</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/漏洞分析/">漏洞分析</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/程序分析/">程序分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/MyBlog/categories/逆向-利用/">逆向&利用</a><span class="category-list-count">1</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/MyBlog/tags/ReverseMe/" style="font-size: 15px;">ReverseMe</a> <a href="/MyBlog/tags/C/" style="font-size: 15px;">C++</a> <a href="/MyBlog/tags/driller/" style="font-size: 15px;">driller</a> <a href="/MyBlog/tags/symbolic-execution/" style="font-size: 15px;">symbolic execution</a> <a href="/MyBlog/tags/ELF/" style="font-size: 15px;">ELF</a> <a href="/MyBlog/tags/IDA/" style="font-size: 15px;">IDA</a> <a href="/MyBlog/tags/crash/" style="font-size: 15px;">crash</a> <a href="/MyBlog/tags/heap-buffer-overflow/" style="font-size: 15px;">heap buffer overflow</a> <a href="/MyBlog/tags/null-pointer-dereference/" style="font-size: 15px;">null pointer dereference</a> <a href="/MyBlog/tags/oss/" style="font-size: 15px;">oss</a> <a href="/MyBlog/tags/peach/" style="font-size: 15px;">peach</a> <a href="/MyBlog/tags/fuzz/" style="font-size: 15px;">fuzz</a> <a href="/MyBlog/tags/reverse/" style="font-size: 15px;">reverse</a> <a href="/MyBlog/tags/markdown/" style="font-size: 15px;">markdown</a> <a href="/MyBlog/tags/symfuzz/" style="font-size: 15px;">symfuzz</a> <a href="/MyBlog/tags/symbolic-analysis/" style="font-size: 15px;">symbolic analysis</a> <a href="/MyBlog/tags/BAP/" style="font-size: 15px;">BAP</a> <a href="/MyBlog/tags/zzuf/" style="font-size: 15px;">zzuf</a> <a href="/MyBlog/tags/调试器/" style="font-size: 15px;">调试器</a> <a href="/MyBlog/tags/web/" style="font-size: 15px;">web</a> <a href="/MyBlog/tags/xss-csrf/" style="font-size: 15px;">xss - csrf</a> <a href="/MyBlog/tags/模式识别/" style="font-size: 15px;">模式识别</a> <a href="/MyBlog/tags/sulley/" style="font-size: 15px;">sulley</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/06/27/ReverseMe-1学习笔记/">ReverseMe#1学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/06/14/peach监控/">peach监控</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/06/14/白帽子讲web安全-阅读笔记/">白帽子讲web安全-阅读笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/06/14/Jhead-3-00-Heap-Buffer-Overflow-Vulnerability-2/">Jhead-3.00 Heap Buffer Overflow Vulnerability-2</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/06/01/Jhead-3-00-Heap-Buffer-Overflow-Vulnerability/">Jhead-3.00 Heap Buffer Overflow Vulnerability-1</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/05/09/简单的调试器-MyDebugger/">简单的调试器-MyDebugger</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/04/10/zzuf原理及源码分析/">zzuf原理及源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/02/14/Fuzz/sulley的架构/">sulley的架构</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/01/30/Libbpg-0-9-7-bpgenc-Null-Pointer-Dereference/">Libbpg-0.9.7 (bpgenc) Null Pointer Dereference</a></li><li class="post-list-item"><a class="post-list-link" href="/MyBlog/2017/01/14/Libbpg-0-9-7-bpgdec-Heap-Buffer-Overflow-Vulnerability/">Libbpg-0.9.7 (bpgdec) Heap Buffer Overflow Vulnerability</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/MyBlog/." rel="nofollow">菜鸟の日常.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/MyBlog/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/MyBlog/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/MyBlog/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/MyBlog/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/MyBlog/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/MyBlog/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/MyBlog/js/smartresize.js?v=0.0.0"></script></div></body></html>